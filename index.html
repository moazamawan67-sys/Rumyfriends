<!DOCTYPE html>
<!-- Ø§ÛŒÙ¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø³Ù¹Ø±Ú©Ú†Ø± Ù¾Ù„Ø§Ù†: ÛŒÛ Ø§ÛŒÙ¾Ù„ÛŒÚ©ÛŒØ´Ù† Ø§Ø±Ø¯Ùˆ Ù…ÛŒÚº Ø§ÛŒÚ© Ø³Ù†Ú¯Ù„ Ù¾ÛŒØ¬ Ø§Ù†Ù¹Ø±Ø§ÛŒÚ©Ù¹Ùˆ ÚˆÛŒØ´ Ø¨ÙˆØ±Úˆ Ú©Û’ Ø·ÙˆØ± Ù¾Ø± ÚˆÛŒØ²Ø§Ø¦Ù† Ú©ÛŒ Ú¯Ø¦ÛŒ ÛÛ’ØŒ Ø¬Ùˆ Ù…ÙˆØ¨Ø§Ø¦Ù„ Ú©Û’ Ù„ÛŒÛ’ Ù…ÙˆØ²ÙˆÚº ÛÛ’ØŒ Ø§ÙˆØ± Ù…Ø³ØªØ­Ú©Ù… ÚˆÛŒÙ¹Ø§ Ø³Ù¹ÙˆØ±ÛŒØ¬ Ú©Û’ Ù„ÛŒÛ’ ÙØ§Ø¦Ø± Ø¨ÛŒØ³ ÙØ§Ø¦Ø± Ø³Ù¹ÙˆØ± Ú©Û’ Ø³Ø§ØªÚ¾ Ù…Ú©Ù…Ù„ Ø·ÙˆØ± Ù¾Ø± Ù…Ø±Ø¨ÙˆØ· ÛÛ’Û” -->
<html lang="ur" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø±Ù…ÛŒ Ø³Ú©ÙˆØ± Ù¹Ø±ÛŒÚ©Ø± (ÙØ§Ø¦Ø± Ø¨ÛŒØ³ Ú©Û’ Ø³Ø§ØªÚ¾)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Noto Nastaliq Urdu', serif;
            background-color: #f8fafc; /* slate-50 */
        }
        .urdu-font-bold {
            font-weight: 700;
        }
        .urdu-font-normal {
            font-weight: 400;
        }
        .chart-container {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin-left: auto;
            margin-right: auto;
            height: 300px;
            max-height: 40vh;
        }
        @media (min-width: 640px) {
            .chart-container {
                height: 350px;
            }
        }
        .warning-blink {
            animation: border-blink 1.5s infinite ease-in-out;
            box-shadow: 0 0 16px rgba(234, 179, 8, 0.6);
        }
        @keyframes border-blink {
            0% { border-color: #f59e0b; } /* amber-500 */
            50% { border-color: #fef3c7; } /* amber-100 */
            100% { border-color: #f59e0b; } /* amber-500 */
        }
        input[type="number"]::-webkit-inner-spin-button,
        input[type="number"]::-webkit-outer-spin-button {
            -webkit-appearance: none;
            margin: 0;
        }
        input[type="number"] {
            -moz-appearance: textfield;
        }
        /* Loader styles */
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #06b6d4; /* cyan-500 */
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        /* Override Tailwind RTL issues with number input */
        .score-input {
            text-align: center !important;
        }
        /* History item delete button */
        .delete-btn {
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
            opacity: 0;
            transition: opacity 0.2s;
        }
        .history-item:hover .delete-btn {
            opacity: 1;
        }
        /* Record details modal */
        .record-details-modal {
            max-height: 80vh;
            overflow-y: auto;
        }
        .round-detail-item {
            transition: background-color 0.2s;
        }
        .round-detail-item:hover {
            background-color: #f8fafc;
        }
        /* Lucky and Normal game badges */
        .lucky-badge {
            background-color: #fef3c7;
            color: #d97706;
            border: 1px solid #f59e0b;
        }
        .normal-badge {
            background-color: #dbeafe;
            color: #1d4ed8;
            border: 1px solid #3b82f6;
        }
    </style>
</head>
<body class="text-slate-800">
    <div id="app" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">

        <!-- Loading Indicator -->
        <div id="loading-overlay" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50 transition-opacity duration-500">
            <div class="flex flex-col items-center">
                <div class="loader"></div>
                <p id="loading-text" class="mt-3 urdu-font-bold text-slate-700">ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ ÛÙˆ Ø±ÛØ§ ÛÛ’...</p>
                <p id="auth-status" class="mt-1 text-xs text-slate-500">ØªØµØ¯ÛŒÙ‚ Ú©ÛŒ Ø¬Ø§ Ø±ÛÛŒ ÛÛ’...</p>
            </div>
        </div>

        <header class="flex justify-between items-center mb-6 pb-4 border-b border-slate-200">
            <div>
                <h1 class="text-3xl md:text-4xl urdu-font-bold text-slate-900">Ø±Ù…ÛŒ ÚˆÛŒØ´ Ø¨ÙˆØ±Úˆ</h1>
                <div class="flex items-center gap-2 mt-1">
                    <p id="user-info" class="text-xs text-slate-400 urdu-font-normal">ÛŒÙˆØ²Ø± Ø¢Ø¦ÛŒ ÚˆÛŒ:</p>
                    <!-- Displaying the first few characters of the ID for space, full ID in title attribute -->
                    <span id="user-id-display" class="text-sm text-cyan-600 urdu-font-bold cursor-pointer hover:text-cyan-800 transition-colors" title="Ú©Ø§Ù¾ÛŒ Ú©Ø±Ù†Û’ Ú©Û’ Ù„ÛŒÛ’ Ú©Ù„Ú© Ú©Ø±ÛŒÚº">...</span>
                </div>
                <p id="game-status" class="text-slate-500 urdu-font-normal mt-1">Ú©Ú¾ÛŒÙ„ Ø¬Ø§Ø±ÛŒ ÛÛ’ØŒ Ø­Ø¯ <span id="limit-display-header" class="urdu-font-bold">...</span> ÛÛ’Û”</p>
            </div>
            <button id="settings-btn" aria-label="ØªØ±ØªÛŒØ¨Ø§Øª" class="p-3 rounded-full hover:bg-slate-200 transition-colors duration-200">
                <!-- Settings Icon (Lucide: Settings) -->
                <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-600"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
            </button>
        </header>

        <main>
            <!-- Scoreboard Section -->
            <section id="scoreboard-section" class="mb-8">
                <h2 class="text-2xl urdu-font-bold mb-4">Ù…ÙˆØ¬ÙˆØ¯Û Ø³Ú©ÙˆØ± Ø¨ÙˆØ±Úˆ</h2>
                 <div id="game-over-message" class="hidden p-4 mb-4 text-center bg-red-100 border-r-4 border-red-500 text-red-700 rounded-lg">
                    <p class="urdu-font-bold text-xl mb-3"></p>
                    <div class="flex flex-col sm:flex-row justify-center gap-3">
                         <button id="record-game-btn" class="hidden px-4 py-2 bg-purple-600 text-white urdu-font-normal rounded-lg hover:bg-purple-700 transition-colors disabled:bg-slate-400 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                            <span id="record-text">Ú¯ÛŒÙ… Ø±ÛŒÚ©Ø§Ø±Úˆ Ú©Ø±ÛŒÚº</span>
                            <div id="record-spinner" class="loader hidden w-4 h-4"></div>
                        </button>
                        <button id="reset-game-btn" class="hidden px-4 py-2 bg-cyan-600 text-white urdu-font-normal rounded-lg hover:bg-cyan-700 transition-colors disabled:bg-slate-400 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                             Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ Ú©Ø±ÛŒÚº 
                        </button>
                    </div>
                </div>
                <!-- Player score cards will be injected here -->
                <div id="scoreboard" class="grid grid-cols-2 md:grid-cols-4 gap-4">
                     <p class="col-span-2 md:col-span-4 text-center text-slate-400 urdu-font-normal" id="scoreboard-loading">Ø³Ú©ÙˆØ± Ø¨ÙˆØ±Úˆ Ù„ÙˆÚˆ ÛÙˆ Ø±ÛØ§ ÛÛ’...</p>
                </div>
            </section>

            <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                <div class="lg:col-span-2">
                     <!-- Input Section -->
                     <section id="input-section" class="bg-white p-6 rounded-2xl shadow-md border border-slate-200 h-full">
                        <h2 class="text-2xl urdu-font-bold mb-4">Ù†ÛŒØ§ Ø±Ø§Ø¤Ù†Úˆ Ø¯Ø±Ø¬ Ú©Ø±ÛŒÚº</h2>
                        <div id="round-type-indicator" class="mb-4 p-3 rounded-lg text-center urdu-font-bold text-lg">
                            <!-- Round type will be displayed here -->
                        </div>
                        <div class="space-y-4">
                            <!-- Score inputs will be generated here -->
                            <div id="player-inputs"></div>
                             <p id="score-error" class="text-red-600 text-sm hidden urdu-font-normal">ØºÙ„Ø·ÛŒ: Ø§ÛŒÚ© Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Ø§ Ø³Ú©ÙˆØ± 0 ÛÙˆÙ†Ø§ Ú†Ø§ÛØ¦Û’ØŒ Ø§ÙˆØ± Ø¨Ø§Ù‚ÛŒÙˆÚº Ú©Ø§ 0 Ø³Û’ Ø²ÛŒØ§Ø¯ÛÛ”</p>
                            <button id="save-score-btn" disabled class="w-full bg-cyan-600 text-white urdu-font-bold py-3 px-4 rounded-lg hover:bg-cyan-700 disabled:bg-slate-400 disabled:cursor-not-allowed transition-colors duration-200 flex items-center justify-center gap-2">
                                <span id="save-text">Ø³Ú©ÙˆØ± Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº</span>
                                <div id="save-spinner" class="loader hidden w-4 h-4"></div>
                            </button>
                        </div>
                    </section>
                </div>
                <div class="lg:col-span-3">
                     <!-- Chart Section -->
                     <section id="chart-section" class="bg-white p-6 rounded-2xl shadow-md border border-slate-200">
                        <h2 class="text-2xl urdu-font-bold mb-4">Ø³Ú©ÙˆØ± Ú©Ø§ Ú¯Ø±Ø§Ù</h2>
                        <p class="text-sm text-slate-500 urdu-font-normal mb-3">ÛŒÛ Ú¯Ø±Ø§Ù ÛØ± Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Û’ Ú©Ù„ Ø³Ú©ÙˆØ± Ú©Ùˆ ÛØ± Ø±Ø§Ø¤Ù†Úˆ Ú©Û’ Ø¨Ø¹Ø¯ Ø¸Ø§ÛØ± Ú©Ø±ØªØ§ ÛÛ’Û”</p>
                        <div class="chart-container">
                            <canvas id="score-chart"></canvas>
                        </div>
                    </section>
                </div>
            </div>

            <!-- History Section -->
            <section id="history-section" class="mt-8">
                <h2 class="text-2xl urdu-font-bold mb-4">Ø±Ø§Ø¤Ù†Úˆ Ú©ÛŒ ØªØ§Ø±ÛŒØ®</h2>
                <div class="bg-white rounded-2xl shadow-md border border-slate-200">
                    <!-- Round list will be injected here -->
                    <div id="history-list" class="divide-y divide-slate-200">
                        <p id="no-history-msg" class="p-6 text-center text-slate-500 urdu-font-normal">Ø§Ø¨Ú¾ÛŒ ØªÚ© Ú©ÙˆØ¦ÛŒ Ø±Ø§Ø¤Ù†Úˆ Ù†ÛÛŒÚº Ú©Ú¾ÛŒÙ„Ø§ Ú¯ÛŒØ§Û”</p>
                    </div>
                </div>
            </section>
            
            <!-- Records Section (New) -->
            <section id="records-section" class="mt-8">
                <h2 class="text-2xl urdu-font-bold mb-4 flex justify-between items-center">
                    Ø±ÛŒÚ©Ø§Ø±Úˆ Ø´Ø¯Û Ú¯ÛŒÙ…Ø²
                    <button id="refresh-records-btn" class="text-sm urdu-font-normal text-cyan-600 hover:text-cyan-800 transition-colors flex items-center gap-1">
                        <!-- Refresh Icon (Lucide: RefreshCcw) -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6"></path><path d="M2.5 22v-6h6"></path><path d="M2.5 16a10 10 0 0 1 18.5-4.5M21.5 8a10 10 0 0 1-18.5 4.5"></path></svg>
                         ØªØ§Ø²Û Ú©Ø±ÛŒÚº
                    </button>
                </h2>
                <div class="bg-white rounded-2xl shadow-md border border-slate-200 p-4">
                    <div id="records-list">
                        <p class="text-center text-slate-500 urdu-font-normal" id="records-loading-msg">Ø±ÛŒÚ©Ø§Ø±ÚˆØ² Ù„ÙˆÚˆ ÛÙˆ Ø±ÛÛ’ ÛÛŒÚº...</p>
                    </div>
                </div>
            </section>

        </main>
    </div>

    <!-- Settings Modal -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-md">
            <h2 class="text-2xl urdu-font-bold mb-6 text-center">ØªØ±ØªÛŒØ¨Ø§Øª</h2>
            <div class="space-y-4">
                <div>
                    <label for="game-limit-input" class="block text-sm urdu-font-normal text-slate-600 mb-1">Ú¯ÛŒÙ… Ú©ÛŒ Ø­Ø¯ (Ù„ÙˆØ²Ø± Ø³Ú©ÙˆØ±)</label>
                    <input type="number" id="game-limit-input" min="100" class="w-full p-2 border border-slate-300 rounded-lg text-center" value="800">
                </div>
                <div id="player-name-inputs">
                    <!-- Player name inputs will be generated here -->
                </div>
            </div>
            <div class="mt-8 flex justify-end gap-4">
                <button id="cancel-settings-btn" class="px-4 py-2 bg-slate-200 text-slate-800 urdu-font-normal rounded-lg hover:bg-slate-300 transition-colors">Ù…Ù†Ø³ÙˆØ®</button>
                <button id="save-settings-btn" class="px-4 py-2 bg-cyan-600 text-white urdu-font-bold rounded-lg hover:bg-cyan-700 transition-colors">Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº</button>
            </div>
        </div>
    </div>

    <!-- Record Details Modal -->
    <div id="record-details-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-4xl record-details-modal">
            <h2 class="text-2xl urdu-font-bold mb-6 text-center">Ú¯ÛŒÙ… Ú©ÛŒ Ù…Ú©Ù…Ù„ ØªÙØµÛŒÙ„</h2>
            <div id="record-details-content">
                <!-- Record details will be injected here -->
            </div>
            <div class="mt-8 flex justify-end">
                <button id="close-record-details-btn" class="px-4 py-2 bg-slate-200 text-slate-800 urdu-font-normal rounded-lg hover:bg-slate-300 transition-colors">Ø¨Ù†Ø¯ Ú©Ø±ÛŒÚº</button>
            </div>
        </div>
    </div>
    
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, addDoc, getDocs } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Set Firestore log level for debugging
        setLogLevel('Debug');

        // --- FIREBASE CONFIGURATION & INITIALIZATION ---
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        
        // Load Firebase config from global variable (MANDATORY)
        let firebaseConfig = {};
        try {
            firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        } catch (e) {
            console.error('Failed to parse __firebase_config:', e);
        }

        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        // Firestore paths
        const RECORDS_COLLECTION_PATH = `/artifacts/${appId}/public/data/rummy_records`;
        const GAME_DOC_PATH = (userId) => `/artifacts/${appId}/users/${userId}/game/current`;

        let app, db, auth;
        let userId = null;
        
        // Default State for new games
        const DEFAULT_GAME_STATE = {
            players: [
                { id: 'p1', name: 'Ù…Ø¹Ø¸Ù…', score: 0 },
                { id: 'p2', name: 'Ø§Ù‚Ø³Ø§Ù…', score: 0 },
                { id: 'p3', name: 'ÙˆÙ‚Ø§Ø±', score: 0 },
                { id: 'p4', name: 'Ø²Ø§ÛØ¯', score: 0 },
            ],
            gameLimit: 800,
            warningThreshold: 100,
            history: [],
            isGameOver: false,
            isRecorded: false, // New flag to prevent re-recording the same finished game
        };

        let gameState = {...DEFAULT_GAME_STATE};

        const ui = {
            loadingOverlay: document.getElementById('loading-overlay'),
            loadingText: document.getElementById('loading-text'),
            authStatus: document.getElementById('auth-status'),
            userIdDisplay: document.getElementById('user-id-display'),
            gameStatus: document.getElementById('game-status'),
            limitDisplayHeader: document.getElementById('limit-display-header'),
            scoreboard: document.getElementById('scoreboard'),
            scoreboardLoading: document.getElementById('scoreboard-loading'),
            gameOverMessage: document.getElementById('game-over-message'),
            resetGameBtn: document.getElementById('reset-game-btn'),
            recordGameBtn: document.getElementById('record-game-btn'),
            recordText: document.getElementById('record-text'),
            recordSpinner: document.getElementById('record-spinner'),
            playerInputs: document.getElementById('player-inputs'),
            scoreError: document.getElementById('score-error'),
            saveScoreBtn: document.getElementById('save-score-btn'),
            saveText: document.getElementById('save-text'),
            saveSpinner: document.getElementById('save-spinner'),
            historyList: document.getElementById('history-list'),
            noHistoryMsg: document.getElementById('no-history-msg'),
            settingsBtn: document.getElementById('settings-btn'),
            settingsModal: document.getElementById('settings-modal'),
            gameLimitInput: document.getElementById('game-limit-input'),
            playerNameInputs: document.getElementById('player-name-inputs'),
            cancelSettingsBtn: document.getElementById('cancel-settings-btn'),
            saveSettingsBtn: document.getElementById('save-settings-btn'),
            chartCanvas: document.getElementById('score-chart'),
            recordsList: document.getElementById('records-list'),
            refreshRecordsBtn: document.getElementById('refresh-records-btn'),
            recordDetailsModal: document.getElementById('record-details-modal'),
            recordDetailsContent: document.getElementById('record-details-content'),
            closeRecordDetailsBtn: document.getElementById('close-record-details-btn'),
            roundTypeIndicator: document.getElementById('round-type-indicator'),
        };

        let scoreChart;
        let isSaving = false;
        let isAuthReady = false;

        // --- GAME UTILITIES ---
        const formatScore = (score) => score.toLocaleString('ur-PK');

        // Lucky Game Pattern: 2 Lucky, 3 Normal, 2 Lucky, 3 Normal, ... (5 round cycle)
        const getRoundType = (roundNumber) => {
            // Adjust for 1-based indexing
            const cyclePosition = (roundNumber - 1) % 5;
            return cyclePosition < 2 ? 'lucky' : 'normal';
        };

        const getRoundTypeDisplay = (roundType) => {
            return roundType === 'lucky' ? 'Ù„Ú©ÛŒ Ú¯ÛŒÙ…' : 'Ø³Ø§Ø¯Û Ú¯ÛŒÙ…';
        };

        const getRoundMultiplier = (roundType) => {
            return roundType === 'lucky' ? 2 : 1;
        };

        // Custom Status Message (replaces alerts)
        const setStatus = (message, isError = false) => {
            const statusBox = document.createElement('div');
            statusBox.className = `fixed top-4 left-1/2 transform -translate-x-1/2 p-3 text-center rounded-lg shadow-lg urdu-font-normal z-50 transition-all duration-300 ${isError ? 'bg-red-500 text-white' : 'bg-cyan-600 text-white'}`;
            statusBox.textContent = message;
            document.body.appendChild(statusBox);
            setTimeout(() => statusBox.remove(), 5000);
        };

        // Custom Modal Confirmation (since window.confirm() is disallowed)
        const confirmCustom = (message) => {
             // For this environment, we bypass the modal and assume confirmation
            console.warn("Using simulated confirmation for: " + message);
            return true; 
        }

        // Copy User ID to Clipboard
        const copyUserId = () => {
            if (userId) {
                 // Use document.execCommand('copy') for better compatibility in iframes
                const tempInput = document.createElement('textarea');
                tempInput.value = userId;
                document.body.appendChild(tempInput);
                tempInput.select();
                try {
                    document.execCommand('copy');
                    setStatus("ÛŒÙˆØ²Ø± Ø¢Ø¦ÛŒ ÚˆÛŒ Ú©Ø§Ù¾ÛŒ ÛÙˆ Ú¯ÛŒØ§!");
                } catch (err) {
                    console.error('Could not copy text: ', err);
                    setStatus("ÛŒÙˆØ²Ø± Ø¢Ø¦ÛŒ ÚˆÛŒ Ú©Ø§Ù¾ÛŒ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒÛ”", true);
                }
                document.body.removeChild(tempInput);
            }
        };

        // --- EVENT LISTENERS INITIALIZATION ---
        const initializeEventListeners = () => {
            // Reset Game Button
            ui.resetGameBtn.addEventListener('click', handleResetGame);
            
            // Save Score Button
            ui.saveScoreBtn.addEventListener('click', handleSaveScore);
            
            // Record Game Button
            ui.recordGameBtn.addEventListener('click', handleRecordGame);
            
            // Refresh Records Button
            ui.refreshRecordsBtn.addEventListener('click', () => fetchAndRenderRecords(true));

            // User ID Click
            ui.userIdDisplay.addEventListener('click', copyUserId);
            
            // Settings Button
            ui.settingsBtn.addEventListener('click', () => {
                ui.settingsModal.classList.remove('hidden');
                renderSettingsModal();
            });
            
            // Settings Modal Buttons
            ui.cancelSettingsBtn.addEventListener('click', () => {
                ui.settingsModal.classList.add('hidden');
            });
            
            ui.saveSettingsBtn.addEventListener('click', handleSaveSettings);
            
            // Record Details Modal Button
            ui.closeRecordDetailsBtn.addEventListener('click', () => {
                ui.recordDetailsModal.classList.add('hidden');
            });
            
            // Score Input Validation: Use event delegation for dynamically added inputs
            ui.playerInputs.addEventListener('input', (e) => {
                 if (e.target.classList.contains('score-input')) {
                    validateScoreInputs();
                 }
            });
        };

        // --- FIREBASE AUTHENTICATION & INITIALIZATION ---
        const initializeFirebase = async () => {
            if (Object.keys(firebaseConfig).length === 0) {
                 console.error("Firebase config is empty. Cannot initialize.");
                 ui.authStatus.textContent = 'Ø´Ø±ÙˆØ¹ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ÙØ§Ø¦Ø± Ø¨ÛŒØ³ Ú©Ù†ÙÛŒÚ¯ Ø¯Ø³ØªÛŒØ§Ø¨ Ù†ÛÛŒÚºÛ”';
                 setStatus('ÙØ§Ø¦Ø± Ø¨ÛŒØ³ Ú©Ù†Ú©Ø´Ù† Ù…ÛŒÚº Ù…Ø³Ø¦Ù„Û: Ú©Ù†ÙÛŒÚ¯Ø±ÛŒØ´Ù† Ù†Ø§Ú©Ø§ÙÛŒÛ”', true);
                 // Stop further Firebase attempts if config is missing
                 ui.loadingOverlay.classList.add('opacity-0');
                 setTimeout(() => ui.loadingOverlay.classList.add('hidden'), 500);
                 renderGameUI();
                 return;
            }
            
            try {
                ui.loadingText.textContent = 'ÙØ§Ø¦Ø± Ø¨ÛŒØ³ Ø´Ø±ÙˆØ¹ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
                
                app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);
                
                // Authentication
                if (initialAuthToken) {
                    ui.authStatus.textContent = 'Ø®ØµÙˆØµÛŒ Ù¹ÙˆÚ©Ù† Ø³Û’ Ø³Ø§Ø¦Ù† Ø§Ù† ÛÙˆ Ø±ÛØ§ ÛÛ’...';
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    ui.authStatus.textContent = 'Ø¨Û’ Ù†Ø§Ù… Ø³Ø§Ø¦Ù† Ø§Ù† ÛÙˆ Ø±ÛØ§ ÛÛ’...';
                    await signInAnonymously(auth);
                }
                
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        ui.userIdDisplay.textContent = userId.substring(0, 8) + '...';
                        ui.userIdDisplay.title = userId; // Full ID on hover
                        ui.authStatus.textContent = 'Ú©Ø§Ù…ÛŒØ§Ø¨ Ø³Ø§Ø¦Ù† Ø§Ù†!';
                        isAuthReady = true;
                        
                        // Load game data from Firestore
                        loadGameData();
                    } else {
                        ui.authStatus.textContent = 'Ø³Ø§Ø¦Ù† Ø§Ù† Ù†Ø§Ú©Ø§Ù…Û”';
                        setStatus('Ø³Ø§Ø¦Ù† Ø§Ù† Ù…ÛŒÚº Ù…Ø³Ø¦Ù„Û ÛÛ’Û” ØµÙØ­Û Ø±ÛŒÙØ±ÛŒØ´ Ú©Ø±ÛŒÚºÛ”', true);
                    }
                });
            } catch (error) {
                console.error('Firebase initialization error:', error);
                ui.authStatus.textContent = 'Ø´Ø±ÙˆØ¹ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ' + error.message;
                setStatus('ÙØ§Ø¦Ø± Ø¨ÛŒØ³ Ú©Ù†Ú©Ø´Ù† Ù…ÛŒÚº Ù…Ø³Ø¦Ù„Û: ' + error.message, true);
                
                // Fallback: Hide loading and show UI with default state
                setTimeout(() => {
                    ui.loadingOverlay.classList.add('opacity-0');
                    setTimeout(() => ui.loadingOverlay.classList.add('hidden'), 500);
                    renderGameUI();
                }, 2000);
            }
        };

        // --- FIRESTORE DATA MANAGEMENT ---
        const getGameDocRef = () => doc(db, GAME_DOC_PATH(userId));

        const loadGameData = () => {
            if (!isAuthReady) return;
            
            try {
                ui.loadingText.textContent = 'Ú¯ÛŒÙ… ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
                
                // Real-time listener for current game state
                onSnapshot(getGameDocRef(), (docSnap) => {
                    if (docSnap.exists()) {
                        const data = docSnap.data();
                        // Merge loaded data over default, ensuring structure is maintained
                        gameState = { ...DEFAULT_GAME_STATE, ...data }; 
                        // Ensure players array is correctly structured after merge
                        if (!Array.isArray(gameState.players) || gameState.players.length !== DEFAULT_GAME_STATE.players.length) {
                             console.warn("Restoring player structure to default.");
                             gameState.players = DEFAULT_GAME_STATE.players.map((defaultP, i) => {
                                 const loadedP = data.players ? data.players[i] : {};
                                 return { ...defaultP, ...loadedP }; // Keep loaded name/score if present
                             });
                        }
                        
                        console.log('Game data loaded/updated from Firestore:', gameState);
                    } else {
                        // No existing game, use default state and save it
                        console.log('No existing game found, using default state');
                        saveGameState(); 
                    }
                    
                    // Render UI and hide loading if it's the first time
                    if (ui.loadingOverlay.classList.contains('hidden') === false) {
                        ui.loadingOverlay.classList.add('opacity-0');
                        setTimeout(() => ui.loadingOverlay.classList.add('hidden'), 500);
                    }
                    
                    renderGameUI();
                    // Fetch records after game loads
                    fetchAndRenderRecords();

                }, (error) => {
                    console.error('Error loading game data:', error);
                    ui.loadingText.textContent = 'ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ ÛÙˆÙ†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒÛ”';
                    setStatus('Ú¯ÛŒÙ… ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ ÛÙˆÙ†Û’ Ù…ÛŒÚº Ù…Ø³Ø¦Ù„Û: ' + error.message, true);
                    
                    // Fallback: Use default state if loading fails completely
                    setTimeout(() => {
                        ui.loadingOverlay.classList.add('opacity-0');
                        setTimeout(() => ui.loadingOverlay.classList.add('hidden'), 500);
                        renderGameUI();
                    }, 2000);
                });
            } catch (error) {
                console.error('Error setting up game listener:', error);
            }
        };

        const saveGameState = async () => {
            if (!isAuthReady) {
                console.warn('Authentication not ready, skipping save.');
                return;
            }
            
            try {
                // Ensure player data is clean before saving
                const stateToSave = {
                    ...gameState,
                    players: gameState.players.map(p => ({
                        id: p.id,
                        name: p.name,
                        score: p.score
                    }))
                };
                
                await setDoc(getGameDocRef(), stateToSave);
                console.log('Game state saved to Firestore');
            } catch (error) {
                console.error('Error saving game state:', error);
                setStatus('Ø³Ú©ÙˆØ± Ù…Ø­ÙÙˆØ¸ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ' + error.message, true);
            }
        };

        // --- GAME LOGIC FUNCTIONS ---
        const validateScoreInputs = () => {
            const inputs = document.querySelectorAll('.score-input');
            let zeroCount = 0;
            let hasNegative = false;
            let allEmpty = true;
            let totalValue = 0; // Check if total value is non-zero
            
            inputs.forEach(input => {
                const value = parseInt(input.value) || 0;
                if (value === 0 && input.value !== '') zeroCount++;
                if (value < 0) hasNegative = true;
                if (input.value !== '') allEmpty = false;
                totalValue += value;
            });
            
            // Check 1: Must not be all empty.
            // Check 2: Must not have negative scores.
            // Check 3: Must have exactly one zero score (the declared player)
            // Check 4: The total score must be > 0 (to prevent saving rounds of all zeros)
            const isValid = !allEmpty && !hasNegative && zeroCount === 1 && totalValue > 0;
            ui.saveScoreBtn.disabled = !isValid;
            
            if (!allEmpty && !isValid) {
                ui.scoreError.classList.remove('hidden');
                if (hasNegative) {
                    ui.scoreError.textContent = 'ØºÙ„Ø·ÛŒ: Ø³Ú©ÙˆØ± Ù…Ù†ÙÛŒ Ù†ÛÛŒÚº ÛÙˆ Ø³Ú©ØªØ§Û”';
                } else if (totalValue === 0) {
                     ui.scoreError.textContent = 'ØºÙ„Ø·ÛŒ: Ø§ÛŒÚ© Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Ø§ Ø³Ú©ÙˆØ± 0 ÛÙˆÙ†Ø§ Ú†Ø§ÛØ¦Û’ØŒ Ø§ÙˆØ± Ø¨Ø§Ù‚ÛŒÙˆÚº Ú©Ø§ Ù…Ø«Ø¨ØªÛ”';
                } else {
                    ui.scoreError.textContent = 'ØºÙ„Ø·ÛŒ: ØµØ±Ù Ø§ÛŒÚ© Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Ø§ Ø³Ú©ÙˆØ± 0 ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’ØŒ Ø¨Ø§Ù‚ÛŒ Ù…Ø«Ø¨ØªÛ”';
                }
            } else {
                ui.scoreError.classList.add('hidden');
            }
            
            return isValid;
        };

        const handleSaveScore = async () => {
            if (isSaving || gameState.isGameOver) return;
            
            const inputs = document.querySelectorAll('.score-input');
            const roundScores = [];
            
            // Validate first
            if (!validateScoreInputs()) {
                setStatus('Ø¨Ø±Ø§Û Ú©Ø±Ù… Ø¯Ø±Ø³Øª Ø³Ú©ÙˆØ± Ø¯Ø±Ø¬ Ú©Ø±ÛŒÚºÛ”', true);
                return;
            }
            
            isSaving = true;
            ui.saveScoreBtn.disabled = true;
            ui.saveText.textContent = 'Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
            ui.saveSpinner.classList.remove('hidden');
            
            try {
                // Determine round type and multiplier
                const nextRoundNumber = gameState.history.length + 1;
                const roundType = getRoundType(nextRoundNumber);
                const multiplier = getRoundMultiplier(roundType);
                
                // Collect and process scores
                let loserIndex = -1;
                gameState.players.forEach((player, index) => {
                    const input = inputs[index];
                    const baseScore = parseInt(input.value) || 0;
                    
                    // Determine loser
                    if (baseScore === 0) {
                        loserIndex = index;
                    }
                    
                    roundScores.push(baseScore);
                    
                    // Clear input
                    input.value = '';
                    
                    // Apply score with multiplier to player's total
                    gameState.players[index].score += baseScore * multiplier;
                });
                
                // Create round data
                const round = {
                    timestamp: new Date(),
                    scores: roundScores, // base score
                    roundType: roundType,
                    multiplier: multiplier,
                    actualScores: roundScores.map(score => score * multiplier), // applied score
                    loserIndex: loserIndex // Index of the player who declared/finished the round
                };
                
                gameState.history.unshift(round);
                
                // Check for game over
                checkGameOver();
                
                // Save to Firestore
                await saveGameState();
                
                setStatus(`Ø±Ø§Ø¤Ù†Úˆ Ú©Ø§ Ø³Ú©ÙˆØ± Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ú¯ÛŒØ§! (${getRoundTypeDisplay(roundType)})`);
                
            } catch (error) {
                console.error('Error saving score:', error);
                setStatus('Ø³Ú©ÙˆØ± Ù…Ø­ÙÙˆØ¸ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ' + error.message, true);
            } finally {
                isSaving = false;
                ui.saveText.textContent = 'Ø³Ú©ÙˆØ± Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº';
                ui.saveSpinner.classList.add('hidden');
                validateScoreInputs(); // Re-validate with cleared inputs
                renderGameUI();
            }
        };

        const checkGameOver = () => {
            const losers = gameState.players.filter(player => 
                player.score >= gameState.gameLimit
            );
            
            if (losers.length > 0) {
                gameState.isGameOver = true;
                // Find the player with the highest score (the actual loser for display)
                const actualLoser = losers.reduce((max, player) => 
                    player.score > max.score ? player : max, losers[0]
                );
                // We don't need to save the final loser index in the history here, 
                // as the final scores determine the game result.
            } else {
                gameState.isGameOver = false;
                gameState.isRecorded = false; // Reset if limit was changed or round deleted
            }
        };

        const handleResetGame = async () => {
            if (!confirmCustom('Ú©ÛŒØ§ Ø¢Ù¾ ÙˆØ§Ù‚Ø¹ÛŒ Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ Ú©Ø±Ù†Ø§ Ú†Ø§ÛØªÛ’ ÛÛŒÚºØŸ Ù…ÙˆØ¬ÙˆØ¯Û ÚˆÛŒÙ¹Ø§ Ø¶Ø§Ø¦Ø¹ ÛÙˆ Ø¬Ø§Ø¦Û’ Ú¯Ø§Û”')) {
                return;
            }
            
            ui.resetGameBtn.disabled = true;
            
            try {
                // Reset to default state but keep player names and game limit
                const playerNames = gameState.players.map(p => p.name);
                const currentLimit = gameState.gameLimit;

                gameState = {
                    ...DEFAULT_GAME_STATE,
                    players: DEFAULT_GAME_STATE.players.map((p, i) => ({
                        ...p,
                        name: playerNames[i] || p.name,
                        score: 0 // Explicitly reset score
                    })),
                    gameLimit: currentLimit
                };
                
                await saveGameState();
                setStatus('Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ ÛÙˆ Ú¯ÛŒØ§!');
                
            } catch (error) {
                console.error('Error resetting game:', error);
                setStatus('Ú¯ÛŒÙ… Ø±ÛŒ Ø³ÛŒÙ¹ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ' + error.message, true);
            } finally {
                ui.resetGameBtn.disabled = false;
                renderGameUI();
            }
        };

        const handleRecordGame = async () => {
            if (!gameState.isGameOver || gameState.isRecorded || !userId) return;
            
            ui.recordGameBtn.disabled = true;
            ui.recordText.textContent = 'Ø±ÛŒÚ©Ø§Ø±Úˆ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
            ui.recordSpinner.classList.remove('hidden');
            
            try {
                // Determine Winner/Loser names for easier viewing
                const winner = gameState.players.reduce((min, player) => 
                    player.score < min.score ? player : min, gameState.players[0]);

                const loser = gameState.players.reduce((max, player) => 
                    player.score > max.score ? player : max, gameState.players[0]);
                
                const gameRecord = {
                    timestamp: new Date(),
                    players: gameState.players.map(p => ({
                         id: p.id,
                         name: p.name,
                         score: p.score
                    })),
                    gameLimit: gameState.gameLimit,
                    history: gameState.history,
                    winnerName: winner.name,
                    loserName: loser.name,
                    userId: userId // The ID of the user who recorded the game
                };
                
                // Add to public records collection
                await addDoc(collection(db, RECORDS_COLLECTION_PATH), gameRecord);
                
                // Mark as recorded in current game state
                gameState.isRecorded = true;
                await saveGameState();
                
                setStatus('Ú¯ÛŒÙ… Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ø±ÛŒÚ©Ø§Ø±Úˆ ÛÙˆ Ú¯Ø¦ÛŒ!');
                fetchAndRenderRecords(true); // Refresh records list
                
            } catch (error) {
                console.error('Error recording game:', error);
                setStatus('Ú¯ÛŒÙ… Ø±ÛŒÚ©Ø§Ø±Úˆ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ' + error.message, true);
            } finally {
                ui.recordGameBtn.disabled = false;
                ui.recordText.textContent = 'Ú¯ÛŒÙ… Ø±ÛŒÚ©Ø§Ø±Úˆ Ú©Ø±ÛŒÚº';
                ui.recordSpinner.classList.add('hidden');
                renderGameUI(); // Update UI to show recorded status
            }
        };

        const fetchAndRenderRecords = async (showRefresh = false) => {
            if (!isAuthReady) return;
            
            try {
                if (showRefresh) {
                    ui.recordsList.innerHTML = '<p class="text-center text-slate-500 urdu-font-normal">ØªØ§Ø²Û ÛÙˆ Ø±ÛØ§ ÛÛ’...</p>';
                }
                
                const querySnapshot = await getDocs(collection(db, RECORDS_COLLECTION_PATH));
                const records = [];
                
                querySnapshot.forEach((doc) => {
                    const data = doc.data();
                    // Firestore timestamp conversion
                    const timestamp = data.timestamp && data.timestamp.toDate ? data.timestamp.toDate() : new Date(); 
                    records.push({ id: doc.id, timestamp: timestamp, ...data });
                });
                
                // Sort by timestamp descending
                records.sort((a, b) => b.timestamp - a.timestamp);
                
                renderRecordsList(records);
                
            } catch (error) {
                console.error('Error fetching records:', error);
                ui.recordsList.innerHTML = '<p class="text-center text-red-500 urdu-font-normal">Ø±ÛŒÚ©Ø§Ø±ÚˆØ² Ù„ÙˆÚˆ ÛÙˆÙ†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒÛ”</p>';
            }
        };

        const handleSaveSettings = async () => {
            try {
                const newLimit = parseInt(ui.gameLimitInput.value) || 800;
                
                // Update player names
                const nameInputs = document.querySelectorAll('.player-name-input');
                const updatedPlayers = gameState.players.map((player, index) => ({
                    ...player,
                    name: nameInputs[index].value || player.name
                }));
                
                // Update game state
                gameState.players = updatedPlayers;
                gameState.gameLimit = newLimit;
                
                // Re-check game over with new limit
                checkGameOver();
                
                await saveGameState();
                
                ui.settingsModal.classList.add('hidden');
                setStatus('ØªØ±ØªÛŒØ¨Ø§Øª Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ú¯Ø¦ÛŒÚº!');
                
            } catch (error) {
                console.error('Error saving settings:', error);
                setStatus('ØªØ±ØªÛŒØ¨Ø§Øª Ù…Ø­ÙÙˆØ¸ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ' + error.message, true);
            }
        };

        // --- RECORD DETAILS FUNCTIONS ---
        const showRecordDetails = (record) => {
            ui.recordDetailsContent.innerHTML = '';
            
            // Handle timestamp object or date conversion
            const date = record.timestamp instanceof Date ? record.timestamp : new Date(record.timestamp.seconds * 1000);
            
            const dateString = date.toLocaleDateString('ur-PK', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
            });
            const timeString = date.toLocaleTimeString('ur-PK', {
                hour: '2-digit',
                minute: '2-digit'
            });
            
            // Find winner (lowest score) and loser (highest score) - based on final scores
            const winner = record.players.reduce((min, player) => 
                player.score < min.score ? player : min, record.players[0]);
            const loser = record.players.reduce((max, player) => 
                player.score > max.score ? player : max, record.players[0]);
            
            // Header section
            const headerSection = document.createElement('div');
            headerSection.className = 'mb-6 p-4 bg-slate-50 rounded-xl';
            headerSection.innerHTML = `
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-center md:text-right">
                    <div>
                        <p class="text-sm text-slate-600 urdu-font-normal">ØªØ§Ø±ÛŒØ®</p>
                        <p class="text-lg urdu-font-bold text-slate-900">${dateString}</p>
                        <p class="text-sm text-slate-500">${timeString}</p>
                    </div>
                    <div>
                        <p class="text-sm text-slate-600 urdu-font-normal">Ú¯ÛŒÙ… Ú©ÛŒ Ø­Ø¯</p>
                        <p class="text-lg urdu-font-bold text-slate-900">${formatScore(record.gameLimit)}</p>
                    </div>
                    <div>
                        <p class="text-sm text-slate-600 urdu-font-normal">Ú©Ù„ Ø±Ø§Ø¤Ù†ÚˆØ²</p>
                        <p class="text-lg urdu-font-bold text-slate-900">${record.history.length}</p>
                    </div>
                </div>
            `;
            ui.recordDetailsContent.appendChild(headerSection);
            
            // Final results section
            const resultsSection = document.createElement('div');
            resultsSection.className = 'mb-6';
            resultsSection.innerHTML = `
                <h3 class="text-xl urdu-font-bold mb-4 text-center text-slate-800">Ø­ØªÙ…ÛŒ Ù†ØªØ§Ø¦Ø¬</h3>
                <div class="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-4 gap-4">
                    ${record.players.map(player => `
                        <div class="p-4 border rounded-xl shadow-sm text-center ${player.id === winner.id ? 'bg-green-100 border-green-300' : player.id === loser.id ? 'bg-red-100 border-red-300' : 'bg-white border-slate-200'}">
                            <span class="urdu-font-bold text-lg block ${player.id === winner.id ? 'text-green-700' : player.id === loser.id ? 'text-red-700' : 'text-slate-700'}">
                                ${player.name}
                                ${player.id === winner.id ? ' ğŸ‘‘' : player.id === loser.id ? ' ğŸ’€' : ''}
                            </span>
                            <span class="text-2xl urdu-font-bold block mt-1 ${player.id === winner.id ? 'text-green-600' : player.id === loser.id ? 'text-red-600' : 'text-slate-600'}">
                                ${formatScore(player.score)}
                            </span>
                        </div>
                    `).join('')}
                </div>
            `;
            ui.recordDetailsContent.appendChild(resultsSection);
            
            // Rounds history section
            if (record.history && record.history.length > 0) {
                const roundsSection = document.createElement('div');
                roundsSection.className = 'mb-6';
                roundsSection.innerHTML = `
                    <h3 class="text-xl urdu-font-bold mb-4 text-center text-slate-800">ØªÙ…Ø§Ù… Ø±Ø§Ø¤Ù†ÚˆØ² Ú©ÛŒ ØªÙØµÛŒÙ„</h3>
                `;
                
                const roundsTable = document.createElement('div');
                roundsTable.className = 'space-y-3 max-h-96 overflow-y-auto p-2 bg-slate-50 rounded-xl border border-slate-200';
                
                // Calculate cumulative scores for each round
                const cumulativeScores = record.players.map(() => []);
                
                // Process rounds in chronological order (reverse of history array)
                const chronologicalRounds = [...record.history].reverse();
                
                chronologicalRounds.forEach((round, roundIndex) => {
                    const roundElement = document.createElement('div');
                    roundElement.className = 'round-detail-item p-4 border border-slate-300 rounded-lg bg-white shadow-sm';
                    
                    const roundNumber = roundIndex + 1;
                    const roundDate = round.timestamp.toDate ? round.timestamp.toDate() : new Date(round.timestamp.seconds * 1000);
                    const roundTimeString = roundDate.toLocaleTimeString('ur-PK', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    
                    // Determine round type badge
                    const roundType = round.roundType || getRoundType(roundNumber);
                    const roundTypeText = getRoundTypeDisplay(roundType);
                    const badgeClass = roundType === 'lucky' ? 'lucky-badge' : 'normal-badge';
                    
                    // Update cumulative scores
                    record.players.forEach((player, playerIndex) => {
                        const score = round.actualScores ? round.actualScores[playerIndex] : (round.scores[playerIndex] * (round.multiplier || 1));
                        const previousTotal = cumulativeScores[playerIndex][roundIndex - 1] || 0;
                        cumulativeScores[playerIndex][roundIndex] = previousTotal + score;
                    });
                    
                    roundElement.innerHTML = `
                        <div class="flex justify-between items-center mb-3 pb-2 border-b border-slate-200">
                            <div class="flex items-center gap-2">
                                <span class="urdu-font-bold text-lg text-slate-700">Ø±Ø§Ø¤Ù†Úˆ ${roundNumber}</span>
                                <span class="text-xs px-2 py-1 rounded urdu-font-normal ${badgeClass}">${roundTypeText}</span>
                            </div>
                            <span class="text-sm text-slate-500">${roundTimeString}</span>
                        </div>
                        <div class="grid grid-cols-2 gap-3">
                            ${record.players.map((player, playerIndex) => {
                                const baseScore = round.scores[playerIndex];
                                const actualScore = round.actualScores ? round.actualScores[playerIndex] : (baseScore * (round.multiplier || 1));
                                const isDeclared = baseScore === 0;
                                const cumulativeScore = cumulativeScores[playerIndex][roundIndex];
                                const multiplier = round.multiplier || getRoundMultiplier(roundType);
                                
                                return `
                                    <div class="flex justify-between items-center p-2 rounded ${isDeclared ? 'bg-cyan-50' : actualScore > 0 ? 'bg-red-50' : 'bg-slate-50'}">
                                        <div>
                                            <span class="urdu-font-normal text-sm ${isDeclared ? 'text-cyan-700 font-bold' : 'text-slate-700'}">
                                                ${player.name}
                                            </span>
                                            <div class="text-xs text-slate-500">
                                                <span>Ø³Ú©ÙˆØ±: ${formatScore(baseScore)}${multiplier > 1 ? ` (Ã— ${multiplier})` : ''}</span>
                                                <span class="block text-slate-600 urdu-font-bold">Ú©Ù„: ${formatScore(cumulativeScore)}</span>
                                            </div>
                                        </div>
                                        <span class="urdu-font-bold text-lg ${isDeclared ? 'text-cyan-600' : 'text-red-600'}">
                                            ${formatScore(actualScore)}
                                        </span>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    `;
                    
                    roundsTable.appendChild(roundElement);
                });
                
                roundsSection.appendChild(roundsTable);
                ui.recordDetailsContent.appendChild(roundsSection);
            }
            
            ui.recordDetailsModal.classList.remove('hidden');
        };

        // --- UI RENDERING FUNCTIONS ---
        const renderGameUI = () => {
            renderScoreboard();
            renderPlayerInputs();
            renderHistory();
            updateChart();
            updateGameStatus();
        };

        const renderScoreboard = () => {
            if (ui.scoreboardLoading) ui.scoreboardLoading.remove();
            
            ui.scoreboard.innerHTML = '';
            
            gameState.players.forEach(player => {
                const progress = Math.min((player.score / gameState.gameLimit) * 100, 100);
                const isWarning = player.score >= (gameState.gameLimit - gameState.warningThreshold);
                const isGameOver = gameState.isGameOver;
                const isLoser = isGameOver && player.score >= gameState.gameLimit;
                
                const playerCard = document.createElement('div');
                playerCard.className = `bg-white rounded-xl shadow-lg border-2 p-4 transition-all duration-300 ${
                    isLoser ? 'border-red-500 bg-red-50' : 
                    isWarning ? 'warning-blink border-amber-500' : 'border-slate-200'
                }`;
                
                playerCard.innerHTML = `
                    <h3 class="text-lg urdu-font-bold mb-2 ${isLoser ? 'text-red-700' : 'text-slate-700'}">${player.name}</h3>
                    <p class="text-3xl urdu-font-bold mb-3 ${isLoser ? 'text-red-600' : 'text-slate-900'}">${formatScore(player.score)}</p>
                    <div class="w-full bg-slate-200 rounded-full h-3">
                        <div class="h-3 rounded-full transition-all duration-500 ${
                            isLoser ? 'bg-red-600' : 
                            isWarning ? 'bg-amber-500' : 'bg-cyan-600'
                        }" style="width: ${progress}%"></div>
                    </div>
                    <p class="text-xs text-slate-500 mt-2 urdu-font-normal">Ø­Ø¯: ${formatScore(gameState.gameLimit)}</p>
                `;
                
                ui.scoreboard.appendChild(playerCard);
            });
        };

        const renderPlayerInputs = () => {
            // Disable inputs if game is over
            const isDisabled = gameState.isGameOver;
            
            ui.playerInputs.innerHTML = '';
            
            // Show next round type
            const nextRoundNumber = gameState.history.length + 1;
            const nextRoundType = getRoundType(nextRoundNumber);
            const roundTypeText = getRoundTypeDisplay(nextRoundType);
            const multiplier = getRoundMultiplier(nextRoundType);
            
            const badgeClass = nextRoundType === 'lucky' ? 'lucky-badge' : 'normal-badge';
            ui.roundTypeIndicator.className = `mb-4 p-3 rounded-xl text-center urdu-font-bold text-lg shadow-sm border ${nextRoundType === 'lucky' ? 'bg-amber-50 border-amber-300' : 'bg-blue-50 border-blue-300'}`;
            ui.roundTypeIndicator.innerHTML = `
                <div class="flex items-center justify-center gap-2">
                    <span>Ø§Ú¯Ù„Ø§ Ø±Ø§Ø¤Ù†Úˆ:</span>
                    <span class="px-3 py-1 rounded urdu-font-bold ${badgeClass}">${roundTypeText}</span>
                    ${multiplier > 1 ? `<span class="text-sm text-amber-600">(Ø³Ú©ÙˆØ± ${multiplier} Ú¯Ù†Ø§ ÛÙˆÚº Ú¯Û’)</span>` : ''}
                </div>
            `;
            
            if (isDisabled) {
                ui.playerInputs.innerHTML = '<p class="text-center text-slate-500 urdu-font-normal p-4">Ú¯ÛŒÙ… Ø®ØªÙ… ÛÙˆ Ú†Ú©Ø§ ÛÛ’Û” Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ Ú©Ø±ÛŒÚº ÛŒØ§ Ø±ÛŒÚ©Ø§Ø±Úˆ Ú©Ø±ÛŒÚºÛ”</p>';
                ui.saveScoreBtn.disabled = true;
                return;
            }

            gameState.players.forEach(player => {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'flex flex-col';
                inputGroup.innerHTML = `
                    <label class="text-sm urdu-font-normal text-slate-600 mb-1">${player.name}</label>
                    <input type="number" 
                           class="score-input w-full p-3 border border-slate-300 rounded-lg text-lg text-center focus:border-cyan-500 focus:ring-1 focus:ring-cyan-500" 
                           min="0" 
                           placeholder="0" 
                           inputmode="numeric">
                `;
                ui.playerInputs.appendChild(inputGroup);
            });
            
            validateScoreInputs();
        };

        const renderHistory = () => {
            if (gameState.history.length === 0) {
                ui.noHistoryMsg.classList.remove('hidden');
                ui.historyList.innerHTML = '';
                ui.historyList.appendChild(ui.noHistoryMsg);
                return;
            }
            
            ui.noHistoryMsg.classList.add('hidden');
            ui.historyList.innerHTML = '';
            
            gameState.history.slice(0, 20).forEach((round, roundIndex) => {
                const historyItem = document.createElement('div');
                historyItem.className = 'history-item relative p-4 hover:bg-slate-50 transition-colors';
                
                const roundNumber = gameState.history.length - roundIndex;
                // Handle timestamp object or date conversion
                const date = round.timestamp.toDate ? round.timestamp.toDate() : new Date(round.timestamp.seconds * 1000);
                const timeString = date.toLocaleTimeString('ur-PK', { 
                    hour: '2-digit', 
                    minute: '2-digit' 
                });
                
                // Determine round type badge
                const roundType = round.roundType || getRoundType(roundNumber);
                const roundTypeText = getRoundTypeDisplay(roundType);
                const badgeClass = roundType === 'lucky' ? 'lucky-badge' : 'normal-badge';
                
                let scoresHtml = gameState.players.map((player, playerIndex) => {
                    const baseScore = round.scores[playerIndex];
                    const actualScore = round.actualScores ? round.actualScores[playerIndex] : (baseScore * (round.multiplier || 1));
                    const isDeclared = baseScore === 0;
                    const multiplier = round.multiplier || getRoundMultiplier(roundType);
                    
                    return `
                        <div class="flex justify-between items-center ${isDeclared ? 'bg-cyan-50 -mx-2 px-2 py-1 rounded' : actualScore > 0 ? 'bg-red-50 -mx-2 px-2 py-1 rounded' : ''}">
                            <div>
                                <span class="urdu-font-normal ${isDeclared ? 'text-cyan-700 font-bold' : actualScore > 0 ? 'text-red-700' : ''}">${player.name}</span>
                                ${multiplier > 1 ? `<span class="text-xs text-amber-600 mr-2">(${baseScore} Ã— ${multiplier})</span>` : ''}
                            </div>
                            <span class="urdu-font-bold ${isDeclared ? 'text-cyan-600' : actualScore > 0 ? 'text-red-600' : 'text-slate-700'}">${formatScore(actualScore)}</span>
                        </div>
                    `;
                }).join('');
                
                historyItem.innerHTML = `
                    <!-- Delete button is always on the left in RTL and uses absolute positioning -->
                    <button class="delete-btn text-red-500 hover:text-red-700 text-sm urdu-font-normal p-1 rounded transition-opacity">
                        <!-- Trash Icon (Lucide: Trash2) -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"></path><path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path><path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path><line x1="10" x2="10" y1="11" y2="17"></line><line x1="14" x2="14" y1="11" y2="17"></line></svg>
                    </button>
                    <div class="flex justify-between items-start mb-2">
                        <span class="text-slate-500 text-sm urdu-font-normal">${timeString}</span>
                        <div class="flex items-center gap-2">
                            <span class="bg-cyan-100 text-cyan-800 text-xs px-2 py-1 rounded urdu-font-normal">Ø±Ø§Ø¤Ù†Úˆ ${roundNumber}</span>
                            <span class="text-xs px-2 py-1 rounded urdu-font-normal ${badgeClass}">${roundTypeText}</span>
                        </div>
                    </div>
                    <div class="space-y-1">
                        ${scoresHtml}
                    </div>
                `;
                
                // Add delete functionality
                const deleteBtn = historyItem.querySelector('.delete-btn');
                deleteBtn.addEventListener('click', async () => {
                    if (!confirmCustom('Ú©ÛŒØ§ Ø¢Ù¾ ÙˆØ§Ù‚Ø¹ÛŒ ÛŒÛ Ø±Ø§Ø¤Ù†Úˆ Ø­Ø°Ù Ú©Ø±Ù†Ø§ Ú†Ø§ÛØªÛ’ ÛÛŒÚºØŸ')) return;
                    
                    try {
                        // Remove from history
                        gameState.history.splice(roundIndex, 1);
                        
                        // Recalculate all scores
                        gameState.players.forEach(player => player.score = 0);
                        
                        // Recalculate based on remaining history (in reverse order for correct round numbering)
                        [...gameState.history].reverse().forEach((histRound, histIndex) => {
                            const histRoundNumber = histIndex + 1; // Chronological number
                            // Use stored type/multiplier or recalculate based on new round number
                            const histRoundType = histRound.roundType || getRoundType(histRoundNumber);
                            const histMultiplier = histRound.multiplier || getRoundMultiplier(histRoundType);
                            
                            histRound.scores.forEach((score, idx) => {
                                gameState.players[idx].score += score * histMultiplier;
                            });
                        });
                        
                        // Re-check game over
                        gameState.isGameOver = false; // Must reset first
                        gameState.isRecorded = false; // Reset record status
                        checkGameOver();
                        
                        await saveGameState();
                        setStatus('Ø±Ø§Ø¤Ù†Úˆ Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ø­Ø°Ù ÛÙˆ Ú¯ÛŒØ§!');
                        
                    } catch (error) {
                        console.error('Error deleting round:', error);
                        setStatus('Ø±Ø§Ø¤Ù†Úˆ Ø­Ø°Ù Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ', true);
                    }
                });
                
                ui.historyList.appendChild(historyItem);
            });
        };

        const renderSettingsModal = () => {
            ui.gameLimitInput.value = gameState.gameLimit;
            ui.playerNameInputs.innerHTML = '';
            
            gameState.players.forEach((player, index) => {
                const inputGroup = document.createElement('div');
                inputGroup.className = 'flex flex-col';
                inputGroup.innerHTML = `
                    <label class="block text-sm urdu-font-normal text-slate-600 mb-1">Ú©Ú¾Ù„Ø§Ú‘ÛŒ ${index + 1}</label>
                    <input type="text" 
                           class="player-name-input w-full p-2 border border-slate-300 rounded-lg text-center urdu-font-normal" 
                           value="${player.name}" 
                           maxlength="15"
                           dir="rtl"
                           placeholder="Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Ø§ Ù†Ø§Ù…">
                `;
                ui.playerNameInputs.appendChild(inputGroup);
            });
        };

        const renderRecordsList = (records) => {
            if (records.length === 0) {
                ui.recordsList.innerHTML = '<p class="text-center text-slate-500 urdu-font-normal">Ø§Ø¨Ú¾ÛŒ ØªÚ© Ú©ÙˆØ¦ÛŒ Ø±ÛŒÚ©Ø§Ø±Úˆ Ø´Ø¯Û Ú¯ÛŒÙ… Ù†ÛÛŒÚºÛ”</p>';
                return;
            }
            
            ui.recordsList.innerHTML = '';
            
            records.forEach(record => {
                const recordEl = document.createElement('div');
                recordEl.className = 'p-4 border-b border-slate-200 last:border-b-0 hover:bg-slate-50 transition-colors rounded-xl';
                
                // Handle timestamp object or date conversion
                const date = record.timestamp instanceof Date ? record.timestamp : new Date(record.timestamp.seconds * 1000);
                const dateString = date.toLocaleDateString('ur-PK', {
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                });
                
                // Find winner/loser (or use saved names if available)
                const winnerName = record.winnerName || (record.players.reduce((min, p) => p.score < min.score ? p : min, record.players[0]).name);
                const loserName = record.loserName || (record.players.reduce((max, p) => p.score > max.score ? p : max, record.players[0]).name);

                // Determine winner/loser ID for styling
                const winnerId = record.players.reduce((min, p) => p.score < min.score ? p : min, record.players[0]).id;
                
                recordEl.innerHTML = `
                    <div class="flex justify-between items-start mb-3">
                        <span class="text-slate-700 urdu-font-bold text-lg">${dateString}</span>
                        <span class="bg-purple-100 text-purple-800 text-xs px-3 py-1 rounded-full urdu-font-normal border border-purple-300">Ø­Ø¯: ${formatScore(record.gameLimit)}</span>
                    </div>
                    <div class="flex justify-between items-center bg-green-50 p-2 rounded-lg border border-green-200 mb-2">
                        <span class="urdu-font-normal text-green-700 font-bold">ğŸ‘‘ ÙØ§ØªØ­: ${winnerName}</span>
                        <span class="urdu-font-bold text-green-600 text-xl">${formatScore(record.players.find(p => p.name === winnerName)?.score || 0)}</span>
                    </div>
                     <div class="flex justify-between items-center bg-red-50 p-2 rounded-lg border border-red-200">
                        <span class="urdu-font-normal text-red-700 font-bold">ğŸ’€ ÛØ§Ø±Ù†Û’ ÙˆØ§Ù„Ø§: ${loserName}</span>
                        <span class="urdu-font-bold text-red-600 text-xl">${formatScore(record.players.find(p => p.name === loserName)?.score || 0)}</span>
                    </div>
                    
                    <div class="text-xs text-slate-500 urdu-font-normal text-center mt-3 mb-3">
                        ${record.history.length} Ø±Ø§Ø¤Ù†ÚˆØ² â€¢ ${record.userId === userId ? 'Ø¢Ù¾ Ú©ÛŒ Ú¯ÛŒÙ…' : 'Ù¾Ø¨Ù„Ú© Ø±ÛŒÚ©Ø§Ø±Úˆ'}
                    </div>
                    <div class="flex justify-center">
                        <button class="view-details-btn px-4 py-2 bg-cyan-600 text-white urdu-font-normal rounded-lg hover:bg-cyan-700 transition-colors text-sm flex items-center gap-1">
                            <!-- Eye Icon (Lucide: Eye) -->
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>
                            Ù…Ú©Ù…Ù„ ØªÙØµÛŒÙ„ Ø¯ÛŒÚ©Ú¾ÛŒÚº
                        </button>
                    </div>
                `;
                
                // Add click event for view details button
                const viewDetailsBtn = recordEl.querySelector('.view-details-btn');
                viewDetailsBtn.addEventListener('click', () => {
                    showRecordDetails(record);
                });
                
                ui.recordsList.appendChild(recordEl);
            });
        };

        const updateGameStatus = () => {
            ui.limitDisplayHeader.textContent = formatScore(gameState.gameLimit);
            
            if (gameState.isGameOver) {
                const losers = gameState.players.filter(p => p.score >= gameState.gameLimit);
                const loserNames = losers.map(p => p.name).join('ØŒ ');
                
                ui.gameOverMessage.classList.remove('hidden');
                ui.gameOverMessage.querySelector('p').textContent = 
                    `Ú¯ÛŒÙ… Ø®ØªÙ…! ${loserNames} Ù†Û’ Ø­Ø¯ ${formatScore(gameState.gameLimit)} Ù¾Ø§Ø± Ú©Ø± Ù„ÛŒÛ”`;
                
                ui.resetGameBtn.classList.remove('hidden');
                ui.recordGameBtn.classList.remove('hidden');
                
                ui.recordGameBtn.disabled = gameState.isRecorded;
                
                if (gameState.isRecorded) {
                    ui.recordText.textContent = 'Ù¾ÛÙ„Û’ ÛÛŒ Ø±ÛŒÚ©Ø§Ø±Úˆ ÛÙˆ Ú†Ú©ÛŒ';
                    ui.recordGameBtn.classList.add('opacity-50');
                } else {
                    ui.recordText.textContent = 'Ú¯ÛŒÙ… Ø±ÛŒÚ©Ø§Ø±Úˆ Ú©Ø±ÛŒÚº';
                    ui.recordGameBtn.classList.remove('opacity-50');
                }
                
                ui.gameStatus.innerHTML = `<span class="text-red-600 urdu-font-bold">Ú¯ÛŒÙ… Ø®ØªÙ…! ${loserNames} ÛØ§Ø± Ú¯Ø¦Û’Û”</span>`;
            } else {
                ui.gameOverMessage.classList.add('hidden');
                ui.resetGameBtn.classList.add('hidden');
                ui.recordGameBtn.classList.add('hidden');
                ui.gameStatus.textContent = `Ú©Ú¾ÛŒÙ„ Ø¬Ø§Ø±ÛŒ ÛÛ’ØŒ Ø­Ø¯ ${formatScore(gameState.gameLimit)} ÛÛ’Û”`;
            }
        };

        const updateChart = () => {
            const ctx = ui.chartCanvas.getContext('2d');
            
            // Destroy existing chart if it exists
            if (scoreChart) {
                scoreChart.destroy();
            }
            
            if (gameState.history.length === 0) {
                // Show empty state
                ctx.clearRect(0, 0, ui.chartCanvas.width, ui.chartCanvas.height);
                ctx.font = "16px 'Noto Nastaliq Urdu'";
                ctx.fillStyle = '#94a3b8';
                ctx.textAlign = 'center';
                const containerRect = ui.chartCanvas.getBoundingClientRect();
                ctx.fillText('Ø§Ø¨Ú¾ÛŒ ØªÚ© Ú©ÙˆØ¦ÛŒ ÚˆÛŒÙ¹Ø§ Ù†ÛÛŒÚº ÛÛ’', containerRect.width / 2, containerRect.height / 2);
                return;
            }
            
            // Prepare chart data
            const labels = [];
            
            // Reverse history for chronological order for chart drawing
            const chronologicalHistory = [...gameState.history].reverse();

            const datasets = gameState.players.map((player, index) => {
                const cumulativeScores = [];
                let runningTotal = 0;
                
                chronologicalHistory.forEach((round, roundIndex) => {
                    // Use stored actualScores if available (since recalculation logic might change)
                    const actualScore = round.actualScores ? round.actualScores[index] : 
                        (round.scores[index] * (round.multiplier || getRoundMultiplier(getRoundType(roundIndex + 1))));
                    
                    runningTotal += actualScore;
                    cumulativeScores.push(runningTotal);
                    
                    if (index === 0) {
                        labels.push(`Ø±Ø§Ø¤Ù†Úˆ ${roundIndex + 1}`);
                    }
                });
                
                return {
                    label: player.name,
                    data: cumulativeScores,
                    borderColor: getPlayerColor(index),
                    backgroundColor: getPlayerColor(index) + '20',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.2, // Smoother lines
                    pointRadius: 4,
                    pointHoverRadius: 6
                };
            });
            
            // Add a dataset for the game limit
             datasets.push({
                label: 'Ø­Ø¯',
                data: labels.map(() => gameState.gameLimit),
                borderColor: '#ef4444', // red-500
                borderWidth: 2,
                borderDash: [5, 5],
                fill: false,
                pointRadius: 0,
                tension: 0
            });
            
            scoreChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            rtl: true, // RTL setting for legend
                            labels: {
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif"
                                },
                                usePointStyle: true
                            }
                        },
                        tooltip: {
                            rtl: true, // RTL setting for tooltips
                            titleFont: {
                                family: "'Noto Nastaliq Urdu', serif"
                            },
                            bodyFont: {
                                family: "'Noto Nastaliq Urdu', serif"
                            },
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.y !== null) {
                                        label += formatScore(context.parsed.y);
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            // Ensure RTL rendering for labels
                            reverse: true,
                            ticks: {
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif"
                                }
                            },
                            title: {
                                display: true,
                                text: 'Ø±Ø§Ø¤Ù†Úˆ Ù†Ù…Ø¨Ø±',
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif",
                                    weight: 'bold'
                                }
                            }
                        },
                        y: {
                            beginAtZero: true,
                            ticks: {
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif"
                                }
                            },
                            title: {
                                display: true,
                                text: 'Ú©Ù„ Ø³Ú©ÙˆØ±',
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif",
                                    weight: 'bold'
                                }
                            }
                        }
                    }
                }
            });
        };

        const getPlayerColor = (index) => {
            // Updated colors for better visibility
            const colors = [
                '#0ea5e9', // sky-500
                '#a855f7', // purple-500
                '#10b981', // emerald-500
                '#f97316'  // orange-500
            ];
            return colors[index % colors.length];
        };

        // --- INITIALIZATION ---
        const init = () => {
            initializeEventListeners();
            initializeFirebase();
        };

        // Start the application
        init();
    </script>
</body>
</html>

