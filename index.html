<!DOCTYPE html>
<html lang="ur" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ø±Ù…ÛŒ Ø³Ú©ÙˆØ± Ù¹Ø±ÛŒÚ©Ø± (Ù…Ù„Ù¹ÛŒ ÚˆÛŒÙˆØ§Ø¦Ø³)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Updated Supabase import to use the modern v2 -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script> 
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <!-- Using Noto Nastaliq Urdu for proper Urdu rendering -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Nastaliq+Urdu:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* Base styles */
        body { font-family: 'Noto Nastaliq Urdu', serif; background-color: #f8fafc; }
        .urdu-font-bold { font-weight: 700; }
        .urdu-font-normal { font-weight: 400; }
        /* Chart container for responsiveness */
        .chart-container { position: relative; width: 100%; max-width: 800px; margin-left: auto; margin-right: auto; height: 300px; max-height: 40vh; }
        @media (min-width: 640px) { .chart-container { height: 350px; } }
        /* Warning blink animation */
        .warning-blink { animation: border-blink 1.5s infinite ease-in-out; box-shadow: 0 0 16px rgba(234, 179, 8, 0.6); }
        @keyframes border-blink { 0% { border-color: #f59e0b; } 50% { border-color: #fef3c7; } 100% { border-color: #f59e0b; } }
        /* Hide number input spin buttons */
        input[type="number"]::-webkit-inner-spin-button, input[type="number"]::-webkit-outer-spin-button { -webkit-appearance: none; margin: 0; }
        input[type="number"] { -moz-appearance: textfield; }
        /* Loader styles */
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #06b6d4; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .score-input { text-align: center !important; }
        /* History item delete button position */
        .delete-btn { position: absolute; left: 1rem; top: 50%; transform: translateY(-50%); opacity: 0; transition: opacity 0.2s; }
        .history-item:hover .delete-btn { opacity: 1; }
        /* Modal scroll */
        .record-details-modal { max-height: 80vh; overflow-y: auto; }
        .round-detail-item { transition: background-color 0.2s; }
        .round-detail-item:hover { background-color: #f8fafc; }
        /* Custom badges */
        .lucky-badge { background-color: #fef3c7; color: #d97706; border: 1px solid #f59e0b; }
        .normal-badge { background-color: #dbeafe; color: #1d4ed8; border: 1px solid #3b82f6; }
        
        /* Dynamic Grid Classes for Scoreboard (Custom Tailwind-like classes) */
        .grid-cols-player-3 { grid-template-columns: repeat(3, minmax(0, 1fr)); }
        .grid-cols-player-5 { grid-template-columns: repeat(5, minmax(0, 1fr)); }
        .grid-cols-player-6 { grid-template-columns: repeat(6, minmax(0, 1fr)); }
    </style>
</head>
<body class="text-slate-800">
    <div id="app" class="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
        <!-- Loading Indicator -->
        <div id="loading-overlay" class="fixed inset-0 bg-white bg-opacity-90 flex items-center justify-center z-50 transition-opacity duration-500">
            <div class="flex flex-col items-center">
                <div class="loader"></div>
                <p id="loading-text" class="mt-3 urdu-font-bold text-slate-700">Ú©Ù„Ø§Ø¤Úˆ ÚˆÛŒÙ¹Ø§ Ù„ÙˆÚˆ ÛÙˆ Ø±ÛØ§ ÛÛ’...</p>
                <p id="auth-status" class="mt-1 text-xs text-slate-500">Supabase Ø³Û’ Ø¬Ú‘ Ø±ÛØ§ ÛÛ’</p>
            </div>
        </div>

        <header class="flex justify-between items-center mb-6 pb-4 border-b border-slate-200">
            <div>
                <h1 class="text-3xl md:text-4xl urdu-font-bold text-slate-900">Ø±Ù…ÛŒ ÚˆÛŒØ´ Ø¨ÙˆØ±Úˆ ğŸŒ</h1>
                <div class="flex items-center gap-2 mt-1">
                    <p id="user-info" class="text-xs text-slate-400 urdu-font-normal">Ú©Ù„Ø§Ø¤Úˆ Ø¢Ø¦ÛŒ ÚˆÛŒ:</p>
                    <span id="user-id-display" class="text-sm text-cyan-600 urdu-font-bold">...</span>
                </div>
                <p id="game-status" class="text-slate-500 urdu-font-normal mt-1">Ú©Ú¾ÛŒÙ„ Ø¬Ø§Ø±ÛŒ ÛÛ’ØŒ Ø­Ø¯ <span id="limit-display-header" class="urdu-font-bold">800</span> ÛÛ’Û”</p>
            </div>
            <div class="flex items-center gap-2">
                <span id="sync-status" class="text-xs bg-green-100 text-green-800 px-2 py-1 rounded urdu-font-normal">ğŸ”„ Ú©Ù„Ø§Ø¤Úˆ Ø³ÛŒÙ†Ú©</span>
                <button id="settings-btn" aria-label="ØªØ±ØªÛŒØ¨Ø§Øª" class="p-3 rounded-full hover:bg-slate-200 transition-colors duration-200">
                    <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="text-slate-600"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>
                </button>
            </div>
        </header>

        <main>
            <!-- Scoreboard Section -->
            <section id="scoreboard-section" class="mb-8">
                <h2 class="text-2xl urdu-font-bold mb-4">Ù…ÙˆØ¬ÙˆØ¯Û Ø³Ú©ÙˆØ± Ø¨ÙˆØ±Úˆ</h2>
                 <div id="game-over-message" class="hidden p-4 mb-4 text-center bg-red-100 border-r-4 border-red-500 text-red-700 rounded-lg">
                    <p class="urdu-font-bold text-xl mb-3"></p>
                    <div class="flex flex-col sm:flex-row justify-center gap-3">
                         <button id="record-game-btn" class="hidden px-4 py-2 bg-purple-600 text-white urdu-font-normal rounded-lg hover:bg-purple-700 transition-colors disabled:bg-slate-400 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                            <span id="record-text">Ú¯ÛŒÙ… Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº</span>
                            <div id="record-spinner" class="loader hidden w-4 h-4"></div>
                        </button>
                        <button id="reset-game-btn" class="hidden px-4 py-2 bg-cyan-600 text-white urdu-font-normal rounded-lg hover:bg-cyan-700 transition-colors disabled:bg-slate-400 disabled:cursor-not-allowed flex items-center justify-center gap-2">
                             Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ Ú©Ø±ÛŒÚº 
                        </button>
                    </div>
                </div>
                <!-- Ø³Ú©ÙˆØ± Ø¨ÙˆØ±Úˆ Ú©Ø§ Ú¯Ø±Úˆ Ù…ØªØ­Ø±Ú© Ø·ÙˆØ± Ù¾Ø± JavaScript Ù…ÛŒÚº Ø³ÛŒÙ¹ Ú©ÛŒØ§ Ø¬Ø§Ø¦Û’ Ú¯Ø§ -->
                <div id="scoreboard" class="grid grid-cols-2 gap-4"> 
                     <p class="col-span-2 md:col-span-4 text-center text-slate-400 urdu-font-normal" id="scoreboard-loading">Ø³Ú©ÙˆØ± Ø¨ÙˆØ±Úˆ Ú©Ù„Ø§Ø¤Úˆ Ø³Û’ Ù„ÙˆÚˆ ÛÙˆ Ø±ÛØ§ ÛÛ’...</p>
                </div>
            </section>

            <div class="grid grid-cols-1 lg:grid-cols-5 gap-8">
                <div class="lg:col-span-2">
                     <section id="input-section" class="bg-white p-6 rounded-2xl shadow-md border border-slate-200 h-full">
                        <h2 class="text-2xl urdu-font-bold mb-4">Ù†ÛŒØ§ Ø±Ø§Ø¤Ù†Úˆ Ø¯Ø±Ø¬ Ú©Ø±ÛŒÚº</h2>
                        <div id="round-type-indicator" class="mb-4 p-3 rounded-lg text-center urdu-font-bold text-lg"></div>
                        <div class="space-y-4">
                            <!-- Ù¾Ù„ÛŒØ¦Ø± Ø§Ù† Ù¾Ù¹Ø³ ÛŒÛØ§Úº Ø±ÛŒÙ†ÚˆØ± ÛÙˆÚº Ú¯Û’ -->
                            <div id="player-inputs"></div>
                             <p id="score-error" class="text-red-600 text-sm hidden urdu-font-normal">ØºÙ„Ø·ÛŒ: Ø§ÛŒÚ© Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Ø§ Ø³Ú©ÙˆØ± 0 ÛÙˆÙ†Ø§ Ú†Ø§ÛØ¦Û’ØŒ Ø§ÙˆØ± Ø¨Ø§Ù‚ÛŒÙˆÚº Ú©Ø§ 0 Ø³Û’ Ø²ÛŒØ§Ø¯ÛÛ”</p>
                            <button id="save-score-btn" disabled class="w-full bg-cyan-600 text-white urdu-font-bold py-3 px-4 rounded-lg hover:bg-cyan-700 disabled:bg-slate-400 disabled:cursor-not-allowed transition-colors duration-200 flex items-center justify-center gap-2">
                                <span id="save-text">Ø³Ú©ÙˆØ± Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº</span>
                                <div id="save-spinner" class="loader hidden w-4 h-4"></div>
                            </button>
                        </div>
                    </section>
                </div>
                <div class="lg:col-span-3">
                     <section id="chart-section" class="bg-white p-6 rounded-2xl shadow-md border border-slate-200">
                        <h2 class="text-2xl urdu-font-bold mb-4">Ø³Ú©ÙˆØ± Ú©Ø§ Ú¯Ø±Ø§Ù</h2>
                        <p class="text-sm text-slate-500 urdu-font-normal mb-3">ÛŒÛ Ú¯Ø±Ø§Ù ÛØ± Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Û’ Ú©Ù„ Ø³Ú©ÙˆØ± Ú©Ùˆ ÛØ± Ø±Ø§Ø¤Ù†Úˆ Ú©Û’ Ø¨Ø¹Ø¯ Ø¸Ø§ÛØ± Ú©Ø±ØªØ§ ÛÛ’Û”</p>
                        <div class="chart-container">
                            <canvas id="score-chart"></canvas>
                        </div>
                    </section>
                </div>
            </div>

            <!-- History Section -->
            <section id="history-section" class="mt-8">
                <h2 class="text-2xl urdu-font-bold mb-4">Ø±Ø§Ø¤Ù†Úˆ Ú©ÛŒ ØªØ§Ø±ÛŒØ®</h2>
                <div class="bg-white rounded-2xl shadow-md border border-slate-200">
                    <div id="history-list" class="divide-y divide-slate-200">
                        <p id="no-history-msg" class="p-6 text-center text-slate-500 urdu-font-normal">Ø§Ø¨Ú¾ÛŒ ØªÚ© Ú©ÙˆØ¦ÛŒ Ø±Ø§Ø¤Ù†Úˆ Ù†ÛÛŒÚº Ú©Ú¾ÛŒÙ„Ø§ Ú¯ÛŒØ§Û”</p>
                    </div>
                </div>
            </section>
            
            <!-- Records Section -->
            <section id="records-section" class="mt-8">
                <h2 class="text-2xl urdu-font-bold mb-4 flex justify-between items-center">
                    ØªÙ…Ø§Ù… ÚˆÛŒÙˆØ§Ø¦Ø³Ø² Ù¾Ø± Ø±ÛŒÚ©Ø§Ø±Úˆ Ø´Ø¯Û Ú¯ÛŒÙ…Ø²
                    <button id="refresh-records-btn" class="text-sm urdu-font-normal text-cyan-600 hover:text-cyan-800 transition-colors flex items-center gap-1">
                        <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21.5 2v6h-6"></path><path d="M2.5 22v-6h6"></path><path d="M2.5 16a10 10 0 0 1 18.5-4.5M21.5 8a10 10 0 0 1-18.5 4.5"></path></svg>
                         Ú©Ù„Ø§Ø¤Úˆ Ø³Û’ ØªØ§Ø²Û Ú©Ø±ÛŒÚº
                    </button>
                </h2>
                <div class="bg-white rounded-2xl shadow-md border border-slate-200 p-4">
                    <div id="records-list">
                        <p class="text-center text-slate-500 urdu-font-normal" id="records-loading-msg">Ú©Ù„Ø§Ø¤Úˆ Ø³Û’ Ø±ÛŒÚ©Ø§Ø±ÚˆØ² Ù„ÙˆÚˆ ÛÙˆ Ø±ÛÛ’ ÛÛŒÚº...</p>
                    </div>
                </div>
            </section>

        </main>
    </div>

    <!-- Settings Modal (Updated for dynamic player management) -->
    <div id="settings-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-md">
            <h2 class="text-2xl urdu-font-bold mb-6 text-center">ØªØ±ØªÛŒØ¨Ø§Øª</h2>
            <div class="space-y-4">
                <div>
                    <label for="game-limit-input" class="block text-sm urdu-font-normal text-slate-600 mb-1">Ú¯ÛŒÙ… Ú©ÛŒ Ø­Ø¯ (Ù„ÙˆØ²Ø± Ø³Ú©ÙˆØ±)</label>
                    <input type="number" id="game-limit-input" min="100" class="w-full p-2 border border-slate-300 rounded-lg text-center" value="800">
                </div>

                <!-- DYNAMIC PLAYER MANAGEMENT SECTION -->
                <div id="player-name-inputs-container">
                    <div class="flex justify-between items-center mb-2">
                        <label class="block text-sm urdu-font-normal text-slate-600">Ú©Ú¾Ù„Ø§Ú‘ÛŒÙˆÚº Ú©Û’ Ù†Ø§Ù…</label>
                        <div class="flex gap-2">
                            <!-- Remove Player Button -->
                            <button id="remove-player-btn" class="text-red-600 hover:bg-red-50 p-1 rounded-full disabled:opacity-50 transition-colors" title="Ú©Ú¾Ù„Ø§Ú‘ÛŒ ÛÙ¹Ø§Ø¦ÛŒÚº">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M5 12h14"></path></svg>
                            </button>
                            <!-- Add Player Button -->
                            <button id="add-player-btn" class="text-cyan-600 hover:bg-cyan-50 p-1 rounded-full disabled:opacity-50 transition-colors" title="Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ø´Ø§Ù…Ù„ Ú©Ø±ÛŒÚº">
                                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 5v14M5 12h14"></path></svg>
                            </button>
                        </div>
                    </div>
                    <div id="player-name-inputs" class="space-y-3">
                        <!-- Dynamic player name inputs will be rendered here -->
                    </div>
                </div>
            </div>
            <div class="mt-8 flex justify-end gap-4">
                <button id="cancel-settings-btn" class="px-4 py-2 bg-slate-200 text-slate-800 urdu-font-normal rounded-lg hover:bg-slate-300 transition-colors">Ù…Ù†Ø³ÙˆØ®</button>
                <button id="save-settings-btn" class="px-4 py-2 bg-cyan-600 text-white urdu-font-bold rounded-lg hover:bg-cyan-700 transition-colors">Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº</button>
            </div>
        </div>
    </div>

    <!-- Record Details Modal -->
    <div id="record-details-modal" class="fixed inset-0 bg-black bg-opacity-60 flex items-center justify-center p-4 hidden z-50">
        <div class="bg-white rounded-2xl shadow-2xl p-6 md:p-8 w-full max-w-4xl record-details-modal">
            <h2 class="text-2xl urdu-font-bold mb-6 text-center">Ú¯ÛŒÙ… Ú©ÛŒ Ù…Ú©Ù…Ù„ ØªÙØµÛŒÙ„</h2>
            <div id="record-details-content"></div>
            <div class="mt-8 flex justify-end">
                <button id="close-record-details-btn" class="px-4 py-2 bg-slate-200 text-slate-800 urdu-font-normal rounded-lg hover:bg-slate-300 transition-colors">Ø¨Ù†Ø¯ Ú©Ø±ÛŒÚº</button>
            </div>
        </div>
    </div>

    <script>
        // ==================== SUPABASE CONFIGURATION ====================
        const SUPABASE_URL = 'https://gwrlnukpeeiykpxnlmsd.supabase.co';
        const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Imd3cmxudWtwZWVpeWtweG5sbXNkIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjEwNzQyMDUsImV4cCI6MjA3NjY1MDIwNX0.WQJxd8KqwSCvE62ypdBRdHArl9UZfE4zUXlZRNnnDxc';

        // Initialize Supabase
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

        // ==================== DEFAULT STATE ====================
        // The default state now supports dynamic player count.
        const DEFAULT_GAME_STATE = {
            players: [
                { id: 'p1', name: 'Ù…Ø¹Ø¸Ù…', score: 0 },
                { id: 'p2', name: 'Ø§Ù‚Ø³Ø§Ù…', score: 0 },
                { id: 'p3', name: 'ÙˆÙ‚Ø§Ø±', score: 0 },
                { id: 'p4', name: 'Ø²Ø§ÛØ¯', score: 0 },
            ],
            gameLimit: 800,
            warningThreshold: 100,
            history: [],
            isGameOver: false,
            isRecorded: false,
            lastUpdated: new Date()
        };

        let gameState = {...DEFAULT_GAME_STATE};
        let userId = null;
        let isOnline = false;

        // ==================== UI ELEMENTS ====================
        const ui = {
            loadingOverlay: document.getElementById('loading-overlay'),
            loadingText: document.getElementById('loading-text'),
            authStatus: document.getElementById('auth-status'),
            userIdDisplay: document.getElementById('user-id-display'),
            gameStatus: document.getElementById('game-status'),
            limitDisplayHeader: document.getElementById('limit-display-header'),
            scoreboard: document.getElementById('scoreboard'),
            scoreboardLoading: document.getElementById('scoreboard-loading'),
            gameOverMessage: document.getElementById('game-over-message'),
            resetGameBtn: document.getElementById('reset-game-btn'),
            recordGameBtn: document.getElementById('record-game-btn'),
            recordText: document.getElementById('record-text'),
            recordSpinner: document.getElementById('record-spinner'),
            playerInputs: document.getElementById('player-inputs'),
            scoreError: document.getElementById('score-error'),
            saveScoreBtn: document.getElementById('save-score-btn'),
            saveText: document.getElementById('save-text'),
            saveSpinner: document.getElementById('save-spinner'),
            historyList: document.getElementById('history-list'),
            noHistoryMsg: document.getElementById('no-history-msg'),
            settingsBtn: document.getElementById('settings-btn'),
            settingsModal: document.getElementById('settings-modal'),
            gameLimitInput: document.getElementById('game-limit-input'),
            playerNameInputs: document.getElementById('player-name-inputs'),
            cancelSettingsBtn: document.getElementById('cancel-settings-btn'),
            saveSettingsBtn: document.getElementById('save-settings-btn'),
            chartCanvas: document.getElementById('score-chart'),
            recordsList: document.getElementById('records-list'),
            refreshRecordsBtn: document.getElementById('refresh-records-btn'),
            recordDetailsModal: document.getElementById('record-details-modal'),
            recordDetailsContent: document.getElementById('record-details-content'),
            closeRecordDetailsBtn: document.getElementById('close-record-details-btn'),
            roundTypeIndicator: document.getElementById('round-type-indicator'),
            syncStatus: document.getElementById('sync-status'),
            // New UI elements for dynamic player count management
            addPlayerBtn: document.getElementById('add-player-btn'), 
            removePlayerBtn: document.getElementById('remove-player-btn'), 
            playerNameInputsContainer: document.getElementById('player-name-inputs-container') 
        };

        let scoreChart;
        let isSaving = false;

        // ==================== UTILITY FUNCTIONS ====================
        const formatScore = (score) => score.toLocaleString('ur-PK');

        const getRoundType = (roundNumber) => {
            // Lucky game on round 1, 2, 6, 7, 11, 12 etc. (First two rounds of every 5-round cycle are lucky)
            const cyclePosition = (roundNumber - 1) % 5;
            return cyclePosition < 2 ? 'lucky' : 'normal';
        };

        const getRoundTypeDisplay = (roundType) => {
            return roundType === 'lucky' ? 'Ù„Ú©ÛŒ Ú¯ÛŒÙ…' : 'Ø³Ø§Ø¯Û Ú¯ÛŒÙ…';
        };

        const getRoundMultiplier = (roundType) => {
            return roundType === 'lucky' ? 2 : 1;
        };

        const setStatus = (message, isError = false) => {
            const statusBox = document.createElement('div');
            statusBox.className = `p-3 mb-4 text-center rounded-lg urdu-font-normal ${isError ? 'bg-red-100 text-red-700' : 'bg-cyan-100 text-cyan-700'}`;
            statusBox.textContent = message;
            document.querySelector('main').prepend(statusBox);
            setTimeout(() => statusBox.remove(), 5000);
        };

        const updateSyncStatus = (isConnected) => {
            isOnline = isConnected;
            if (isConnected) {
                ui.syncStatus.textContent = 'âœ… Ú©Ù„Ø§Ø¤Úˆ Ø³ÛŒÙ†Ú©';
                ui.syncStatus.className = 'text-xs bg-green-100 text-green-800 px-2 py-1 rounded urdu-font-normal';
            } else {
                ui.syncStatus.textContent = 'âš ï¸ Ø¢Ù Ù„Ø§Ø¦Ù†';
                ui.syncStatus.className = 'text-xs bg-yellow-100 text-yellow-800 px-2 py-1 rounded urdu-font-normal';
            }
        };

        // Helper function to get dynamic grid class based on player count
        const getPlayerGridClass = (playerCount) => {
            if (playerCount === 2) return 'grid-cols-2';
            if (playerCount === 3) return 'grid-cols-3';
            if (playerCount === 5) return 'grid-cols-5';
            if (playerCount === 6) return 'grid-cols-6';
            // Default for 4 players or other fallbacks
            return 'grid-cols-2 md:grid-cols-4'; 
        };

        // ==================== SUPABASE AUTHENTICATION ====================
        const initializeAuth = async () => {
            try {
                ui.loadingText.textContent = 'Supabase Ú©Ù†Ú©Ø´Ù† Ù¹ÛŒØ³Ù¹ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
                
                // Test authentication
                const { data: authData, error: authError } = await supabase.auth.signInAnonymously();
                if (authError) {
                    console.error('Authentication failed:', authError);
                    throw authError;
                }
                
                console.log('âœ… Authentication successful');
                
                // Get the current session
                const { data: { session } } = await supabase.auth.getSession();
                userId = session.user.id;
                
                ui.userIdDisplay.textContent = userId.substring(0, 8) + '...';
                updateSyncStatus(true);
                
                console.log('âœ… Supabase initialization successful');
                return true;
                
            } catch (error) {
                console.error('âŒ Supabase initialization failed:', error);
                
                // Fallback to localStorage
                setStatus('Supabase Ú©Ù†Ú©Ø´Ù† Ù†Ø§Ú©Ø§Ù…ØŒ Ù…Ù‚Ø§Ù…ÛŒ Ù…ÙˆÚˆ Ù…ÛŒÚº Ú©Ø§Ù… Ø¬Ø§Ø±ÛŒ ÛÛ’', true);
                updateSyncStatus(false);
                
                // Generate local user ID
                userId = localStorage.getItem('rummy_user_id') || 'local_' + Date.now();
                localStorage.setItem('rummy_user_id', userId);
                ui.userIdDisplay.textContent = userId.substring(0, 8) + '... (Ù…Ù‚Ø§Ù…ÛŒ)';
                
                return false;
            }
        };

        // ==================== DATA MANAGEMENT ====================
        const saveGameState = async () => {
            const stateToSave = {
                ...gameState,
                lastUpdated: new Date().toISOString()
            };

            if (!isOnline) {
                // Save to localStorage
                try {
                    localStorage.setItem('rummy_current_game', JSON.stringify(stateToSave));
                    console.log('âœ… Saved to localStorage');
                    return true;
                } catch (error) {
                    console.error('âŒ localStorage save failed:', error);
                    return false;
                }
            }

            try {
                const { data, error } = await supabase
                    .from('rummy_games')
                    .upsert({
                        id: userId,
                        game_data: stateToSave,
                        last_updated: new Date().toISOString()
                    }, {
                        onConflict: 'id'
                    });

                if (error) {
                    console.error('âŒ Supabase save error:', error);
                    // Fallback to localStorage
                    localStorage.setItem('rummy_current_game', JSON.stringify(stateToSave));
                    return true;
                }

                console.log('âœ… Saved to Supabase');
                return true;
            } catch (error) {
                console.error('âŒ Save failed, using localStorage:', error);
                localStorage.setItem('rummy_current_game', JSON.stringify(stateToSave));
                return true;
            }
        };

        const loadGameState = async () => {
            // First try Supabase
            if (isOnline) {
                try {
                    const { data, error } = await supabase
                        .from('rummy_games')
                        .select('*')
                        .eq('id', userId)
                        .single();

                    if (!error && data && data.game_data) {
                        gameState = {
                            ...DEFAULT_GAME_STATE,
                            ...data.game_data,
                            history: data.game_data.history || [],
                            players: data.game_data.players || DEFAULT_GAME_STATE.players
                        };
                        // Ensure IDs are sequential after loading (important for consistency)
                        gameState.players = gameState.players.map((p, i) => ({
                            ...p,
                            id: 'p' + (i + 1)
                        }));
                        console.log('âœ… Loaded from Supabase');
                        return true;
                    }
                } catch (error) {
                    console.log('Supabase load failed, trying localStorage...');
                }
            }

            // Fallback to localStorage
            try {
                const saved = localStorage.getItem('rummy_current_game');
                if (saved) {
                    const data = JSON.parse(saved);
                    gameState = {
                        ...DEFAULT_GAME_STATE,
                        ...data,
                        history: data.history || [],
                        players: data.players || DEFAULT_GAME_STATE.players
                    };
                    // Ensure IDs are sequential after loading (important for consistency)
                    gameState.players = gameState.players.map((p, i) => ({
                        ...p,
                        id: 'p' + (i + 1)
                    }));
                    console.log('âœ… Loaded from localStorage');
                }
                return true;
            } catch (error) {
                console.error('âŒ Load failed:', error);
                return false;
            }
        };

        // ==================== REAL-TIME UPDATES ====================
        const startRealtimeListener = () => {
            if (!isOnline) {
                console.log('Offline mode, skipping realtime listener');
                return;
            }

            try {
                const subscription = supabase
                    .channel('rummy-game-updates')
                    .on(
                        'postgres_changes',
                        {
                            event: '*',
                            schema: 'public',
                            table: 'rummy_games',
                            filter: `id=eq.${userId}`
                        },
                        (payload) => {
                            console.log('Real-time update received:', payload);
                            
                            if (payload.new && payload.new.id === userId) {
                                gameState = {
                                    ...DEFAULT_GAME_STATE,
                                    ...payload.new.game_data,
                                    history: payload.new.game_data.history || [],
                                    players: payload.new.game_data.players || DEFAULT_GAME_STATE.players
                                };
                                // Re-assign IDs to ensure consistency after load
                                gameState.players = gameState.players.map((p, i) => ({
                                    ...p,
                                    id: 'p' + (i + 1)
                                }));
                                renderGameUI();
                                setStatus('Ú©Ù„Ø§Ø¤Úˆ Ø³Û’ ØªØ§Ø²Û ÚˆÛŒÙ¹Ø§ Ù…Ù„ Ú¯ÛŒØ§', false);
                            }
                        }
                    )
                    .subscribe((status) => {
                        console.log('Realtime subscription status:', status);
                    });

                return subscription;
            } catch (error) {
                console.error('Realtime listener error:', error);
                return null;
            }
        };

        // ==================== EVENT LISTENERS ====================
        const initializeEventListeners = () => {
            ui.resetGameBtn.addEventListener('click', handleResetGame);
            ui.saveScoreBtn.addEventListener('click', handleSaveScore);
            ui.recordGameBtn.addEventListener('click', handleRecordGame);
            ui.refreshRecordsBtn.addEventListener('click', () => fetchAndRenderRecords(true));
            ui.settingsBtn.addEventListener('click', () => {
                ui.settingsModal.classList.remove('hidden');
                renderSettingsModal();
            });
            ui.cancelSettingsBtn.addEventListener('click', () => {
                ui.settingsModal.classList.add('hidden');
            });
            ui.saveSettingsBtn.addEventListener('click', handleSaveSettings);
            ui.closeRecordDetailsBtn.addEventListener('click', () => {
                ui.recordDetailsModal.classList.add('hidden');
            });

            // New: Dynamic Player Management Listeners
            ui.addPlayerBtn.addEventListener('click', handleAddPlayer);
            ui.removePlayerBtn.addEventListener('click', handleRemovePlayer);
            
            // Score input validation
            ui.playerInputs.addEventListener('input', (e) => {
                if (e.target.classList.contains('score-input')) {
                    validateScoreInputs();
                }
            });

            // Online/Offline detection
            window.addEventListener('online', () => {
                updateSyncStatus(true);
                setStatus('Ú©Ù„Ø§Ø¤Úˆ Ú©Ù†Ú©Ø´Ù† Ø¨Ø­Ø§Ù„ ÛÙˆ Ú¯ÛŒØ§');
                loadGameState().then(() => renderGameUI());
            });

            window.addEventListener('offline', () => {
                updateSyncStatus(false);
                setStatus('Ø¢Ù Ù„Ø§Ø¦Ù† Ù…ÙˆÚˆ: Ú©Ù„Ø§Ø¤Úˆ Ú©Ù†Ú©Ø´Ù† Ù…Ù†Ù‚Ø·Ø¹', true);
            });
        };

        // ==================== DYNAMIC PLAYER MANAGEMENT ====================

        const updatePlayerCountButtons = () => {
            // Ø²ÛŒØ§Ø¯Û Ø³Û’ Ø²ÛŒØ§Ø¯Û 6 Ú©Ú¾Ù„Ø§Ú‘ÛŒ
            ui.addPlayerBtn.disabled = gameState.players.length >= 6; 
            // Ú©Ù… Ø§Ø² Ú©Ù… 2 Ú©Ú¾Ù„Ø§Ú‘ÛŒ
            ui.removePlayerBtn.disabled = gameState.players.length <= 2; 
        };

        const handleAddPlayer = () => {
            if (gameState.players.length < 6) {
                const nextId = 'p' + (gameState.players.length + 1);
                gameState.players.push({
                    id: nextId,
                    name: `Ú©Ú¾Ù„Ø§Ú‘ÛŒ ${gameState.players.length + 1}`,
                    score: 0
                });
                renderSettingsModal();
                setStatus('Ø§ÛŒÚ© Ù†ÛŒØ§ Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ø´Ø§Ù…Ù„ Ú©Ø± Ø¯ÛŒØ§ Ú¯ÛŒØ§Û” Ù…Ø­ÙÙˆØ¸ Ú©Ø±Ù†Û’ Ú©Û’ Ø¨Ø¹Ø¯ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ Ú©Ø±ÛŒÚºÛ”');
            } else {
                setStatus('Ø²ÛŒØ§Ø¯Û Ø³Û’ Ø²ÛŒØ§Ø¯Û 6 Ú©Ú¾Ù„Ø§Ú‘ÛŒÙˆÚº Ú©Ùˆ Ø´Ø§Ù…Ù„ Ú©ÛŒØ§ Ø¬Ø§ Ø³Ú©ØªØ§ ÛÛ’Û”', true);
            }
        };

        const handleRemovePlayer = () => {
            if (gameState.players.length > 2) {
                const removedPlayer = gameState.players.pop();
                
                // IDs and names are fine, but the history data will become inconsistent if game is running.
                if (gameState.history.length > 0) {
                     setStatus(`Ø®Ø¨Ø±Ø¯Ø§Ø±: ${removedPlayer.name} Ú©Ùˆ ÛÙ¹Ø§Ù†Û’ Ø³Û’ Ù…ÙˆØ¬ÙˆØ¯Û Ø³Ú©ÙˆØ± Ø§ÙˆØ± ØªØ§Ø±ÛŒØ® Ù…ÛŒÚº Ø®Ù„Ù„ Ù¾Ú‘ Ø³Ú©ØªØ§ ÛÛ’Û” Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ Ú©Ø±Ù†Ø§ Ø¨ÛØªØ± ÛÛ’Û”`, true);
                }
                
                // Re-index IDs
                gameState.players = gameState.players.map((p, i) => ({
                    ...p,
                    id: 'p' + (i + 1)
                }));
                
                renderSettingsModal();
                setStatus(`${removedPlayer.name} Ú©Ùˆ ÙÛØ±Ø³Øª Ø³Û’ ÛÙ¹Ø§ Ø¯ÛŒØ§ Ú¯ÛŒØ§Û”`);
            } else {
                setStatus('Ú¯ÛŒÙ… Ù…ÛŒÚº Ú©Ù… Ø§Ø² Ú©Ù… 2 Ú©Ú¾Ù„Ø§Ú‘ÛŒ ÛÙˆÙ†Û’ Ú†Ø§ÛØ¦ÛŒÚº!', true);
            }
        };
        
        // ==================== GAME LOGIC ====================
        const validateScoreInputs = () => {
            const inputs = document.querySelectorAll('.score-input');
            let zeroCount = 0;
            let hasNegative = false;
            let allEmpty = true;
            
            inputs.forEach(input => {
                const value = parseInt(input.value) || 0;
                if (value === 0) zeroCount++;
                if (value < 0) hasNegative = true;
                if (input.value !== '') allEmpty = false;
            });
            
            const isValid = !allEmpty && !hasNegative && zeroCount === 1;
            ui.saveScoreBtn.disabled = !isValid || gameState.isGameOver;
            
            if (!allEmpty && (!isValid || hasNegative)) {
                ui.scoreError.classList.remove('hidden');
                ui.scoreError.textContent = 'ØºÙ„Ø·ÛŒ: ØµØ±Ù Ø§ÛŒÚ© Ú©Ú¾Ù„Ø§Ú‘ÛŒ Ú©Ø§ Ø³Ú©ÙˆØ± 0 ÛÙˆÙ†Ø§ Ú†Ø§ÛÛŒÛ’ØŒ Ø¨Ø§Ù‚ÛŒ Ù…Ø«Ø¨ØªÛ”';
            } else {
                ui.scoreError.classList.add('hidden');
            }
            
            return isValid;
        };

        const handleSaveScore = async () => {
            if (isSaving || gameState.isGameOver) return;
            
            const inputs = document.querySelectorAll('.score-input');
            const roundScores = [];
            
            // Get scores from inputs
            gameState.players.forEach(() => {
                const input = inputs[roundScores.length];
                const score = parseInt(input.value) || 0;
                roundScores.push(score);
            });
            
            if (!validateScoreInputs()) {
                setStatus('Ø¨Ø±Ø§Û Ú©Ø±Ù… Ø¯Ø±Ø³Øª Ø³Ú©ÙˆØ± Ø¯Ø±Ø¬ Ú©Ø±ÛŒÚºÛ”', true);
                return;
            }
            
            isSaving = true;
            ui.saveScoreBtn.disabled = true;
            ui.saveText.textContent = 'Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
            ui.saveSpinner.classList.remove('hidden');
            
            try {
                const nextRoundNumber = gameState.history.length + 1;
                const roundType = getRoundType(nextRoundNumber);
                const multiplier = getRoundMultiplier(roundType);
                
                const round = {
                    timestamp: new Date(),
                    scores: roundScores,
                    roundType: roundType,
                    multiplier: multiplier,
                    actualScores: roundScores.map(score => score * multiplier)
                };
                
                // Update game state immediately
                roundScores.forEach((score, index) => {
                    gameState.players[index].score += score * multiplier;
                });
                
                gameState.history.unshift(round);
                checkGameOver();
                
                // Clear inputs immediately
                inputs.forEach(input => input.value = '');
                
                // Update UI immediately
                renderGameUI();
                
                // Save to database
                const saved = await saveGameState();
                if (saved) {
                    setStatus(`Ø±Ø§Ø¤Ù†Úˆ Ú©Ø§ Ø³Ú©ÙˆØ± Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ú¯ÛŒØ§! (${getRoundTypeDisplay(roundType)})`);
                }
                
            } catch (error) {
                console.error('Error saving score:', error);
                setStatus('Ø³Ú©ÙˆØ± Ù…Ø­ÙÙˆØ¸ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ', true);
            } finally {
                isSaving = false;
                ui.saveText.textContent = 'Ø³Ú©ÙˆØ± Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº';
                ui.saveSpinner.classList.add('hidden');
                validateScoreInputs();
            }
        };

        const checkGameOver = () => {
            const losers = gameState.players.filter(player => 
                player.score >= gameState.gameLimit
            );
            
            if (losers.length > 0) {
                gameState.isGameOver = true;
                const actualLoser = losers.reduce((max, player) => 
                    player.score > max.score ? player : max, losers[0]
                );
                // Find the index of the loser in the current players array
                const loserIndex = gameState.players.findIndex(p => p.id === actualLoser.id);
                if (gameState.history.length > 0) {
                    gameState.history[0].loserIndex = loserIndex;
                }
            }
        };

        const handleResetGame = async () => {
            if (!confirm('Ú©ÛŒØ§ Ø¢Ù¾ ÙˆØ§Ù‚Ø¹ÛŒ Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ Ú©Ø±Ù†Ø§ Ú†Ø§ÛØªÛ’ ÛÛŒÚºØŸ Ù…ÙˆØ¬ÙˆØ¯Û ÚˆÛŒÙ¹Ø§ Ú©Ù„Ø§Ø¤Úˆ Ø³Û’ Ø¨Ú¾ÛŒ Ø­Ø°Ù ÛÙˆ Ø¬Ø§Ø¦Û’ Ú¯Ø§Û”')) {
                return;
            }
            
            const playerNames = gameState.players.map(p => p.name);
            gameState = {
                ...DEFAULT_GAME_STATE,
                players: gameState.players.map((p, i) => ({ // Use current players for reset
                    ...p,
                    name: playerNames[i] || p.name,
                    score: 0 // Reset score to 0
                })),
                gameLimit: gameState.gameLimit,
                history: [], // Clear history
                isGameOver: false, // Reset game over status
                isRecorded: false // Reset recorded status
            };
            
            await saveGameState();
            renderGameUI();
            setStatus('Ù†ÛŒØ§ Ú¯ÛŒÙ… Ø´Ø±ÙˆØ¹ ÛÙˆ Ú¯ÛŒØ§ Ø§ÙˆØ± Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ú¯ÛŒØ§!');
        };

        // ==================== RECORDS MANAGEMENT ====================
        const handleRecordGame = async () => {
            if (!gameState.isGameOver || gameState.isRecorded) return;

            ui.recordGameBtn.disabled = true;
            ui.recordText.textContent = 'Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
            ui.recordSpinner.classList.remove('hidden');
            
            try {
                console.log('Recording game to Supabase...');
                
                const gameRecord = {
                    timestamp: new Date().toISOString(),
                    players: gameState.players,
                    game_limit: gameState.gameLimit,
                    history: gameState.history,
                    final_scores: gameState.players.map(p => p.score),
                    user_id: userId,
                    user_name: 'Anonymous User'
                };
                
                console.log('Game record data:', gameRecord);
                
                if (isOnline) {
                    console.log('Saving to Supabase...');
                    const { data, error } = await supabase
                        .from('rummy_records')
                        .insert([gameRecord]);
                    
                    if (error) {
                        console.error('Supabase insert error:', error);
                        throw error;
                    }
                    
                    console.log('âœ… Game recorded successfully in Supabase');
                } else {
                    // Save to localStorage
                    console.log('Saving to localStorage...');
                    const existingRecords = JSON.parse(localStorage.getItem('rummy_records') || '[]');
                    existingRecords.unshift({...gameRecord, id: 'local_' + Date.now()});
                    localStorage.setItem('rummy_records', JSON.stringify(existingRecords));
                    console.log('âœ… Game recorded successfully in localStorage');
                }
                
                // Mark as recorded and save game state
                gameState.isRecorded = true;
                await saveGameState();
                
                setStatus('Ú¯ÛŒÙ… Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ú¯Ø¦ÛŒ! ØªÙ…Ø§Ù… ÚˆÛŒÙˆØ§Ø¦Ø³Ø² Ø¯ÛŒÚ©Ú¾ Ø³Ú©ÛŒÚº Ú¯ÛŒÛ”');
                fetchAndRenderRecords(true);
                
            } catch (error) {
                console.error('Error recording game:', error);
                setStatus('Ú¯ÛŒÙ… Ø±ÛŒÚ©Ø§Ø±Úˆ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ: ' + error.message, true);
            } finally {
                ui.recordText.textContent = 'Ú¯ÛŒÙ… Ú©Ù„Ø§Ø¤Úˆ Ù…ÛŒÚº Ù…Ø­ÙÙˆØ¸ Ú©Ø±ÛŒÚº';
                ui.recordSpinner.classList.add('hidden');
                ui.recordGameBtn.disabled = gameState.isRecorded;
            }
        };

        const fetchAndRenderRecords = async (showRefresh = false) => {
            try {
                if (showRefresh) {
                    ui.recordsList.innerHTML = '<p class="text-center text-slate-500 urdu-font-normal">ÚˆÛŒÙ¹Ø§ ØªØ§Ø²Û ÛÙˆ Ø±ÛØ§ ÛÛ’...</p>';
                }
                
                let records = [];
                
                if (isOnline) {
                    const { data: onlineRecords, error } = await supabase
                        .from('rummy_records')
                        .select('*')
                        .order('timestamp', { ascending: false })
                        .limit(50);
                    
                    if (!error) records = onlineRecords || [];
                }
                
                // Also get local records
                const localRecords = JSON.parse(localStorage.getItem('rummy_records') || '[]');
                records = [...records, ...localRecords];
                
                // Sort by timestamp
                records.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                
                renderRecordsList(records.slice(0, 50));
                
            } catch (error) {
                console.error('Error fetching records:', error);
                ui.recordsList.innerHTML = '<p class="text-center text-red-500 urdu-font-normal">Ø±ÛŒÚ©Ø§Ø±ÚˆØ² Ù„ÙˆÚˆ ÛÙˆÙ†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒÛ”</p>';
            }
        };

        // ==================== UI RENDERING FUNCTIONS ====================
        const renderGameUI = () => {
            renderScoreboard();
            renderPlayerInputs();
            renderHistory();
            updateGameStatus();
            updateChart();
        };

        const renderScoreboard = () => {
            ui.scoreboardLoading.classList.add('hidden');
            
            // Dynamic grid class calculation
            const playerCount = gameState.players.length;
            let gridClass;
            // Use flex grid for mobile/small screens, and adjust grid columns for medium/large
            if (playerCount === 2) {
                gridClass = 'grid-cols-2';
            } else if (playerCount === 3) {
                gridClass = 'grid-cols-3';
            } else if (playerCount === 5) {
                gridClass = 'grid-cols-2 md:grid-cols-5';
            } else if (playerCount === 6) {
                gridClass = 'grid-cols-2 md:grid-cols-6';
            } else {
                gridClass = 'grid-cols-2 md:grid-cols-4'; // Default for 4
            }
            
            // Apply the dynamic grid class
            ui.scoreboard.className = `grid gap-4 ${gridClass}`;

            ui.scoreboard.innerHTML = gameState.players.map(player => `
                <div class="bg-white p-4 rounded-xl shadow-sm border-2 ${
                    player.score >= gameState.gameLimit ? 'border-red-500 warning-blink' : 
                    player.score >= (gameState.gameLimit - gameState.warningThreshold) ? 'border-yellow-400' : 'border-slate-200'
                } transition-all duration-300">
                    <div class="flex justify-between items-start mb-2">
                        <h3 class="text-lg urdu-font-bold text-slate-800">${player.name}</h3>
                        <span class="text-xs px-2 py-1 rounded-full ${
                            player.score >= gameState.gameLimit ? 'bg-red-100 text-red-800' : 'bg-slate-100 text-slate-600'
                        } urdu-font-normal">${player.id}</span>
                    </div>
                    <p class="text-3xl urdu-font-bold text-slate-900 text-center my-3">${formatScore(player.score)}</p>
                    <div class="flex justify-between text-sm text-slate-500">
                        <span>Ø­Ø¯: ${formatScore(gameState.gameLimit)}</span>
                        <span>ÙØ±Ù‚: ${formatScore(gameState.gameLimit - player.score)}</span>
                    </div>
                </div>
            `).join('');
        };

        const renderPlayerInputs = () => {
            const nextRoundNumber = gameState.history.length + 1;
            const roundType = getRoundType(nextRoundNumber);
            const multiplier = getRoundMultiplier(roundType);
            
            ui.roundTypeIndicator.textContent = `Ø±Ø§Ø¤Ù†Úˆ ${nextRoundNumber} - ${getRoundTypeDisplay(roundType)} (${multiplier}x)`;
            ui.roundTypeIndicator.className = `mb-4 p-3 rounded-lg text-center urdu-font-bold text-lg ${
                roundType === 'lucky' ? 'bg-yellow-100 text-yellow-800 lucky-badge' : 'bg-blue-100 text-blue-800 normal-badge'
            }`;
            
            ui.playerInputs.innerHTML = gameState.players.map((player, index) => `
                <div class="flex items-center gap-3">
                    <label class="w-24 text-sm urdu-font-normal text-slate-600">${player.name}</label>
                    <input type="number" 
                           class="score-input flex-1 p-3 border border-slate-300 rounded-lg urdu-font-bold text-lg" 
                           placeholder="0" 
                           min="0"
                           ${gameState.isGameOver ? 'disabled' : ''}>
                </div>
            `).join('');
            
            validateScoreInputs();
        };

        const renderHistory = () => {
            if (gameState.history.length === 0) {
                ui.noHistoryMsg.classList.remove('hidden');
                ui.historyList.innerHTML = '<p id="no-history-msg" class="p-6 text-center text-slate-500 urdu-font-normal">Ø§Ø¨Ú¾ÛŒ ØªÚ© Ú©ÙˆØ¦ÛŒ Ø±Ø§Ø¤Ù†Úˆ Ù†ÛÛŒÚº Ú©Ú¾ÛŒÙ„Ø§ Ú¯ÛŒØ§Û”</p>';
                return;
            }
            
            ui.noHistoryMsg.classList.add('hidden');
            
            const playerCount = gameState.players.length;
            const historyGridClass = getPlayerGridClass(playerCount); // Use the utility function

            ui.historyList.innerHTML = gameState.history.map((round, index) => {
                const roundNumber = gameState.history.length - index;
                const hasLoser = round.loserIndex !== undefined;
                
                return `
                    <div class="history-item p-4 hover:bg-slate-50 transition-colors relative">
                        <button class="delete-btn p-2 text-red-500 hover:bg-red-50 rounded-lg transition-colors" 
                                data-round-index="${index}">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>
                        </button>
                        
                        <div class="flex justify-between items-center mb-2">
                            <div class="flex items-center gap-2">
                                <span class="text-sm urdu-font-bold text-slate-700">Ø±Ø§Ø¤Ù†Úˆ ${roundNumber}</span>
                                <span class="text-xs px-2 py-1 rounded-full ${
                                    round.roundType === 'lucky' ? 'lucky-badge' : 'normal-badge'
                                } urdu-font-normal">${getRoundTypeDisplay(round.roundType)}</span>
                                ${hasLoser ? '<span class="text-xs bg-red-100 text-red-800 px-2 py-1 rounded urdu-font-normal">Ú¯ÛŒÙ… Ø®ØªÙ…</span>' : ''}
                            </div>
                            <span class="text-xs text-slate-500">${new Date(round.timestamp?.toDate?.() || round.timestamp).toLocaleTimeString('ur-PK')}</span>
                        </div>
                        
                        <div class="grid gap-2 ${historyGridClass}"> 
                            ${round.scores.map((score, playerIndex) => `
                                <div class="text-center p-2 rounded-lg ${
                                    score === 0 ? 'bg-green-100 text-green-800' : 'bg-slate-100 text-slate-700'
                                }">
                                    <div class="text-sm urdu-font-normal">${gameState.players[playerIndex]?.name || 'Ù†Ø§Ù…Ø¹Ù„ÙˆÙ…'}</div>
                                    <div class="text-lg urdu-font-bold">${formatScore(score)}</div>
                                    ${round.multiplier > 1 ? 
                                        `<div class="text-xs text-slate-500">(${formatScore(round.actualScores[playerIndex])})</div>` : ''
                                    }
                                </div>
                            `).join('')}
                        </div>
                    </div>
                `;
            }).join('');
            
            document.querySelectorAll('.delete-btn').forEach(btn => {
                btn.addEventListener('click', async (e) => {
                    const roundIndex = parseInt(e.currentTarget.dataset.roundIndex);
                    await deleteRound(roundIndex);
                });
            });
        };

        const deleteRound = async (roundIndex) => {
            // Use a custom modal for confirmation as alert() is forbidden.
            if (!confirm('Ú©ÛŒØ§ Ø¢Ù¾ ÙˆØ§Ù‚Ø¹ÛŒ ÛŒÛ Ø±Ø§Ø¤Ù†Úˆ Ø­Ø°Ù Ú©Ø±Ù†Ø§ Ú†Ø§ÛØªÛ’ ÛÛŒÚºØŸ')) {
                return;
            }
            
            try {
                const removedRound = gameState.history[roundIndex];
                
                // Recalculate scores by removing the round's scores
                removedRound.actualScores.forEach((score, index) => {
                    if(gameState.players[index]) {
                        gameState.players[index].score -= score;
                    }
                });
                
                gameState.history.splice(roundIndex, 1);
                
                // Re-check game over status
                gameState.isGameOver = false;
                gameState.isRecorded = false;
                checkGameOver();
                
                await saveGameState();
                renderGameUI();
                setStatus('Ø±Ø§Ø¤Ù†Úˆ Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ø­Ø°Ù ÛÙˆ Ú¯ÛŒØ§!');
                
            } catch (error) {
                console.error('Error deleting round:', error);
                setStatus('Ø±Ø§Ø¤Ù†Úˆ Ø­Ø°Ù Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ', true);
            }
        };

        const renderSettingsModal = () => {
            ui.gameLimitInput.value = gameState.gameLimit;
            
            // Update the state of Add/Remove buttons
            updatePlayerCountButtons();
            
            // Render dynamic player name inputs
            ui.playerNameInputs.innerHTML = gameState.players.map((player, index) => `
                <div>
                    <label for="player-name-${index}" class="block text-sm urdu-font-normal text-slate-600 mb-1">Ú©Ú¾Ù„Ø§Ú‘ÛŒ ${index + 1} (ID: ${player.id})</label>
                    <input type="text" 
                           id="player-name-${index}" 
                           class="w-full p-2 border border-slate-300 rounded-lg text-center urdu-font-normal" 
                           value="${player.name}">
                </div>
            `).join('');
        };

        const handleSaveSettings = async () => {
            const newLimit = parseInt(ui.gameLimitInput.value);
            
            if (newLimit < 100) {
                setStatus('Ú¯ÛŒÙ… Ú©ÛŒ Ø­Ø¯ Ú©Ù… Ø§Ø² Ú©Ù… 100 ÛÙˆÙ†ÛŒ Ú†Ø§ÛÛŒÛ’', true);
                return;
            }
            
            // Create a new array of player data from the inputs
            const updatedPlayers = gameState.players.map((player, index) => {
                const input = document.getElementById(`player-name-${index}`);
                return {
                    id: player.id,
                    name: input.value.trim() || `Ú©Ú¾Ù„Ø§Ú‘ÛŒ ${index + 1}`,
                    score: player.score // Preserve current score
                };
            });
            
            gameState.gameLimit = newLimit;
            gameState.players = updatedPlayers;
            
            const saved = await saveGameState();
            if (saved) {
                ui.settingsModal.classList.add('hidden');
                // Re-render everything as player count or names might have changed
                renderGameUI(); 
                setStatus('ØªØ±ØªÛŒØ¨Ø§Øª Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ú¯Ø¦ÛŒÚº!');
            }
        };

        const updateGameStatus = () => {
            ui.limitDisplayHeader.textContent = formatScore(gameState.gameLimit);
            
            if (gameState.isGameOver) {
                const losers = gameState.players.filter(p => p.score >= gameState.gameLimit);
                const actualLoser = losers.reduce((max, player) => 
                    player.score > max.score ? player : max, losers[0]
                );
                
                ui.gameOverMessage.classList.remove('hidden');
                ui.gameOverMessage.querySelector('p').textContent = 
                    `ğŸ¯ Ú¯ÛŒÙ… Ø®ØªÙ…! ${actualLoser.name} ÛØ§Ø± Ú¯Ø¦Û’Û” ÙØ§Ø¦Ù†Ù„ Ø³Ú©ÙˆØ±: ${formatScore(actualLoser.score)}`;
                
                ui.resetGameBtn.classList.remove('hidden');
                ui.recordGameBtn.classList.remove('hidden');
                ui.recordGameBtn.disabled = gameState.isRecorded;
                
                if (gameState.isRecorded) {
                    ui.recordText.textContent = 'âœ… Ù…Ø­ÙÙˆØ¸ ÛÙˆ Ú†Ú©ÛŒ';
                }
            } else {
                ui.gameOverMessage.classList.add('hidden');
                ui.resetGameBtn.classList.add('hidden');
                ui.recordGameBtn.classList.add('hidden');
            }
        };

        const updateChart = () => {
            const ctx = ui.chartCanvas.getContext('2d');
            
            if (scoreChart) {
                scoreChart.destroy();
            }
            
            if (gameState.history.length === 0) {
                return;
            }
            
            // Chart labels are reversed to show round 1 first
            const labels = gameState.history.map((_, index) => `Ø±Ø§Ø¤Ù†Úˆ ${gameState.history.length - index}`).reverse();
            const datasets = gameState.players.map((player, playerIndex) => {
                const color = getPlayerColor(playerIndex);
                const cumulativeScores = [];
                let total = 0;
                
                [...gameState.history].reverse().forEach(round => {
                    // Check if score exists for this player index (handles case where player count was reduced)
                    const score = round.actualScores[playerIndex] || 0; 
                    total += score;
                    cumulativeScores.push(total);
                });
                
                return {
                    label: player.name,
                    data: cumulativeScores,
                    borderColor: color,
                    backgroundColor: color + '20',
                    borderWidth: 3,
                    fill: false,
                    tension: 0.4,
                    pointBackgroundColor: color,
                    pointBorderColor: '#fff',
                    pointBorderWidth: 2,
                    pointRadius: 4,
                    pointHoverRadius: 6
                };
            });
            
            scoreChart = new Chart(ctx, {
                type: 'line',
                data: { labels, datasets },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'top',
                            rtl: true,
                            labels: {
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif",
                                    size: 12
                                },
                                padding: 20
                            }
                        },
                        tooltip: {
                            rtl: true,
                            titleFont: {
                                family: "'Noto Nastaliq Urdu', serif"
                            },
                            bodyFont: {
                                family: "'Noto Nastaliq Urdu', serif"
                            }
                        }
                    },
                    scales: {
                        x: {
                            ticks: {
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif"
                                },
                                maxRotation: 45
                            },
                            grid: {
                                display: false
                            }
                        },
                        y: {
                            ticks: {
                                font: {
                                    family: "'Noto Nastaliq Urdu', serif"
                                },
                                callback: function(value) {
                                    return formatScore(value);
                                }
                            }
                        }
                    }
                }
            });
        };

        const getPlayerColor = (index) => {
            const colors = [
                '#06b6d4', // cyan
                '#8b5cf6', // purple
                '#10b981', // green
                '#f59e0b',  // yellow
                '#ef4444', // red (new)
                '#3b82f6' // blue (new)
            ];
            return colors[index % colors.length];
        };

        const renderRecordsList = (records) => {
            if (records.length === 0) {
                ui.recordsList.innerHTML = '<p class="text-center text-slate-500 urdu-font-normal">Ø§Ø¨Ú¾ÛŒ ØªÚ© Ú©ÙˆØ¦ÛŒ Ø±ÛŒÚ©Ø§Ø±Úˆ Ø´Ø¯Û Ú¯ÛŒÙ… Ù†ÛÛŒÚº ÛÛ’Û”</p>';
                return;
            }
            
            ui.recordsList.innerHTML = records.map(record => {
                const timestamp = record.timestamp?.toDate?.() || new Date(record.timestamp) || new Date();
                const players = record.players || [];
                if (players.length === 0) return '';
                
                // Calculate winner dynamically
                const winner = players.reduce((min, player) => 
                    player.score < min.score ? player : min, players[0]
                );
                
                const recordGridClass = getPlayerGridClass(players.length); // Use the utility function
                
                return `
                    <div class="p-4 border border-slate-200 rounded-lg mb-3 hover:bg-slate-50 transition-colors cursor-pointer record-item" data-record-id="${record.id || 'local'}">
                        <div class="flex justify-between items-start mb-2">
                            <div>
                                <h3 class="urdu-font-bold text-slate-800">${timestamp.toLocaleDateString('ur-PK')}</h3>
                                <p class="text-sm text-slate-600 urdu-font-normal">${timestamp.toLocaleTimeString('ur-PK')}</p>
                            </div>
                            <span class="text-xs bg-cyan-100 text-cyan-800 px-2 py-1 rounded urdu-font-normal">Ø­Ø¯: ${formatScore(record.game_limit || record.gameLimit)}</span>
                        </div>
                        
                        <div class="grid gap-2 mb-3 ${recordGridClass}">
                            ${players.map(player => `
                                <div class="text-center p-2 rounded-lg ${
                                    player.id === winner.id ? 'bg-green-100 text-green-800 border border-green-300' : 'bg-slate-100 text-slate-700'
                                }">
                                    <div class="text-sm urdu-font-normal">${player.name}</div>
                                    <div class="text-lg urdu-font-bold">${formatScore(player.score)}</div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div class="flex justify-between items-center text-xs text-slate-500">
                            <span class="urdu-font-normal">ÙØ§ØªØ­: ${winner.name}</span>
                            <span class="urdu-font-normal">Ø±Ø§Ø¤Ù†ÚˆØ²: ${record.history?.length || 0}</span>
                        </div>
                    </div>
                `;
            }).join('');
            
            document.querySelectorAll('.record-item').forEach(item => {
                item.addEventListener('click', (e) => {
                    const recordId = e.currentTarget.dataset.recordId;
                    // Find record in the combined array
                    const record = records.find(r => (r.id === recordId) || (r.id === 'local_' + recordId.split('_')[1] && recordId.startsWith('local_')));
                    if (record) {
                        showRecordDetails(record);
                    }
                });
            });
        };

        const showRecordDetails = (record) => {
            const players = record.players || [];
            if (players.length === 0) return;

            const winner = players.reduce((min, player) => 
                player.score < min.score ? player : min, players[0]
            );
            
            const detailGridClass = getPlayerGridClass(players.length);

            ui.recordDetailsContent.innerHTML = `
                <div class="mb-6">
                    <h3 class="text-xl urdu-font-bold mb-4 text-center">ÙØ§Ø¦Ù†Ù„ Ø³Ú©ÙˆØ± Ø¨ÙˆØ±Úˆ</h3>
                    <div class="grid gap-4 ${detailGridClass}">
                        ${players.map(player => `
                            <div class="text-center p-4 rounded-xl ${
                                player.id === winner.id ? 'bg-green-100 border-2 border-green-400' : 'bg-slate-100 border border-slate-300'
                            }">
                                <div class="text-lg urdu-font-bold mb-2 ${player.id === winner.id ? 'text-green-800' : 'text-slate-800'}">${player.name}</div>
                                <div class="text-2xl urdu-font-bold ${player.id === winner.id ? 'text-green-900' : 'text-slate-900'}">${formatScore(player.score)}</div>
                                ${player.id === winner.id ? 
                                    '<div class="mt-2 text-sm urdu-font-normal text-green-700">ğŸ† ÙØ§ØªØ­</div>' : 
                                    `<div class="mt-2 text-sm urdu-font-normal text-slate-600">ÙØ±Ù‚: ${formatScore(player.score - winner.score)}</div>`
                                }
                            </div>
                        `).join('')}
                    </div>
                </div>
                
                <div>
                    <h4 class="text-lg urdu-font-bold mb-3">ØªÙ…Ø§Ù… Ø±Ø§Ø¤Ù†ÚˆØ² Ú©ÛŒ ØªÙØµÛŒÙ„</h4>
                    <div class="space-y-3 max-h-96 overflow-y-auto">
                        ${(record.history || []).map((round, index) => {
                            const roundNumber = index + 1;
                            const roundType = getRoundType(roundNumber);
                            
                            return `
                                <div class="round-detail-item p-3 border border-slate-200 rounded-lg">
                                    <div class="flex justify-between items-center mb-2">
                                        <span class="urdu-font-bold text-slate-700">Ø±Ø§Ø¤Ù†Úˆ ${roundNumber}</span>
                                        <span class="text-xs px-2 py-1 rounded-full ${
                                            roundType === 'lucky' ? 'lucky-badge' : 'normal-badge'
                                        } urdu-font-normal">${getRoundTypeDisplay(roundType)}</span>
                                    </div>
                                    <div class="grid gap-2 ${detailGridClass}">
                                        ${round.scores.map((score, playerIndex) => `
                                            <div class="text-center p-2 rounded ${
                                                score === 0 ? 'bg-green-100 text-green-800' : 'bg-slate-100 text-slate-700'
                                            }">
                                                <div class="text-sm urdu-font-normal">${players[playerIndex]?.name || 'Ù†Ø§Ù…Ø¹Ù„ÙˆÙ…'}</div>
                                                <div class="urdu-font-bold">${formatScore(score)}</div>
                                                ${round.multiplier > 1 ? 
                                                    `<div class="text-xs text-slate-500">(${formatScore(round.actualScores[playerIndex])})</div>` : ''
                                                }
                                            </div>
                                        `).join('')}
                                    </div>
                                </div>
                            `;
                        }).join('')}
                    </div>
                </div>
            `;
            
            ui.recordDetailsModal.classList.remove('hidden');
        };

        // ==================== INITIALIZE APP ====================
        const init = async () => {
            initializeEventListeners();
            
            try {
                ui.loadingText.textContent = 'Ø³Ø³Ù¹Ù… Ø´Ø±ÙˆØ¹ ÛÙˆ Ø±ÛØ§ ÛÛ’...';
                
                const authSuccess = await initializeAuth();
                
                if (authSuccess) {
                    await loadGameState();
                    
                    if (isOnline) {
                        startRealtimeListener();
                        setStatus('Supabase Ø³Û’ Ú©Ø§Ù…ÛŒØ§Ø¨ÛŒ Ø³Û’ Ø¬Ú‘ Ú¯ÛŒØ§! ØªÙ…Ø§Ù… ÚˆÛŒÙˆØ§Ø¦Ø³Ø² Ø³ÛŒÙ†Ú© ÛÙˆÚº Ú¯ÛŒÛ”', false);
                    } else {
                        setStatus('Ù…Ù‚Ø§Ù…ÛŒ Ù…ÙˆÚˆ: ÚˆÛŒÙ¹Ø§ ØµØ±Ù Ø§Ø³ ÚˆÛŒÙˆØ§Ø¦Ø³ Ù¾Ø± Ù…Ø­ÙÙˆØ¸ ÛÙˆÚ¯Ø§', false);
                    }
                    
                    renderGameUI();
                    fetchAndRenderRecords();
                } else {
                    // Local mode
                    await loadGameState();
                    renderGameUI();
                    fetchAndRenderRecords();
                    setStatus('Ù…Ù‚Ø§Ù…ÛŒ Ù…ÙˆÚˆ Ù…ÛŒÚº Ú©Ø§Ù… Ø¬Ø§Ø±ÛŒ ÛÛ’', false);
                }
                
            } catch (error) {
                console.error('Initialization failed:', error);
                setStatus('Ø§ÛŒÙ¾ Ø´Ø±ÙˆØ¹ Ú©Ø±Ù†Û’ Ù…ÛŒÚº Ù†Ø§Ú©Ø§Ù…ÛŒ', true);
            } finally {
                setTimeout(() => {
                    ui.loadingOverlay.classList.add('opacity-0');
                    setTimeout(() => ui.loadingOverlay.classList.add('hidden'), 500);
                }, 2000);
            }
        };

        // Start the application
        init();
    </script>
</body>
</html>

